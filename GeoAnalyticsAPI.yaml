swagger: '2.0'
info:
  description: Explore the content of geospatial data collections
  version: 21.0.0
  title: Geo Analytics API
  contact:
    name: Gisaia
    url: http://www.gisaia.com/
    email: contact@gisaia.com
  license:
    name: Apache 2.0
    url: https://www.apache.org/licenses/LICENSE-2.0.html
basePath: /
tags:
  - name: collections
  - name: explore
schemes:
  - http
  - https
paths:
  /collections/{collection}:
    get:
      tags:
        - collections
      summary: Get a collection reference
      description: Get a geospatial data collection reference
      operationId: get
      consumes:
        - application/json;charset=utf-8
      produces:
        - application/json;charset=utf-8
      parameters:
        - name: collection
          in: path
          description: collection
          required: true
          type: string
        - name: pretty
          in: query
          description: Pretty print
          required: false
          type: boolean
          default: false
      responses:
        '200':
          description: Successful operation
          schema:
            $ref: '#/definitions/CollectionReference'
        '404':
          description: Collection not found.
          schema:
            $ref: '#/definitions/Error'
        '500':
          description: Server Error.
          schema:
            $ref: '#/definitions/Error'
    put:
      tags:
        - collections
      summary: Add a collection reference
      description: Add a geospatial data collection reference
      operationId: put
      consumes:
        - application/json;charset=utf-8
      produces:
        - application/json;charset=utf-8
      parameters:
        - name: collection
          in: path
          description: collection
          required: true
          type: string
        - in: body
          name: collectionParams
          description: collectionParams
          required: true
          schema:
            $ref: '#/definitions/CollectionReferenceParameters'
        - name: pretty
          in: query
          description: Pretty print
          required: false
          type: boolean
          default: false
        - name: checkFields
          in: query
          required: false
          type: boolean
          default: true
      responses:
        '200':
          description: Successful operation
          schema:
            $ref: '#/definitions/CollectionReference'
        '400':
          description: JSON parameter malformed.
          schema:
            $ref: '#/definitions/Error'
        '404':
          description: Not Found Error.
          schema:
            $ref: '#/definitions/Error'
        '500':
          description: Server Error.
          schema:
            $ref: '#/definitions/Error'
    delete:
      tags:
        - collections
      summary: Delete a geospatial data collection reference
      description: Delete a collection reference
      operationId: delete
      consumes:
        - application/json;charset=utf-8
      produces:
        - application/json;charset=utf-8
      parameters:
        - name: collection
          in: path
          description: collection
          required: true
          type: string
        - name: pretty
          in: query
          description: Pretty print
          required: false
          type: boolean
          default: false
      responses:
        '200':
          description: Successful operation
          schema:
            $ref: '#/definitions/Success'
        '404':
          description: Collection not found.
          schema:
            $ref: '#/definitions/Error'
        '500':
          description: Server Error.
          schema:
            $ref: '#/definitions/Error'
  /collections:
    get:
      tags:
        - collections
      summary: Get all collection references
      description: Get all geospatial data collection references
      operationId: getAll
      consumes:
        - application/json;charset=utf-8
      produces:
        - application/json;charset=utf-8
      parameters:
        - name: pretty
          in: query
          description: Pretty print
          required: false
          type: boolean
          default: false
      responses:
        '200':
          description: Successful operation
          schema:
            type: array
            items:
              $ref: '#/definitions/CollectionReference'
        '500':
          description: Server Error.
          schema:
            $ref: '#/definitions/Error'
  /collections/_export:
    get:
      tags:
        - collections
      summary: Get all collection references as a json file
      description: Get all geospatial data collection references as json file
      operationId: exportCollections
      consumes:
        - application/json;charset=utf-8
      produces:
        - application/json;charset=utf-8
      parameters: []
      responses:
        '200':
          description: Successful operation
          schema:
            type: array
            items:
              $ref: '#/definitions/CollectionReference'
        '500':
          description: Server Error.
          schema:
            $ref: '#/definitions/Error'
  /collections/_import:
    post:
      tags:
        - collections
      summary: Add collection references from a json file
      description: Add geospatial data collection references from a json file
      operationId: importCollections
      consumes:
        - multipart/form-data
      produces:
        - application/json;charset=utf-8
      parameters:
        - name: file
          in: formData
          required: false
          type: file
      responses:
        '200':
          description: Successful operation
          schema:
            type: string
        '500':
          description: Server Error.
          schema:
            $ref: '#/definitions/Error'
  /explore/{collection}/_aggregate:
    get:
      tags:
        - explore
      summary: Aggregate
      description: Aggregate the elements in the collection(s), given the filters and the aggregation parameters
      operationId: aggregate
      consumes:
        - application/json;charset=utf-8
      produces:
        - application/json;charset=utf-8
      parameters:
        - name: collection
          in: path
          description: collection
          required: true
          type: string
        - name: agg
          in: query
          description: |-
            - The agg parameter should be given in the following formats:

                   {type}:{field}:interval-{interval}:format-{format}:collect_field-{collect_field}:collect_fct-{function}:order-{order}:on-{on}:size-{size}:fetch_hits-{fetch_hits values}

            Where :

               - **{type}:{field}** part is mandatory.

               - **interval** must be specified only when aggregation type is datehistogram, histogram, geotile and geohash.

               - **format** is optional for datehistogram, and must not be specified for the other types.

               - (**collect_field**,**collect_fct**) couple is optional for all aggregation types.

               - It's possible to apply multiple metric aggregations by defining multiple (**collect_field**,**collect_fct**) couples.

               - (**collect_field**,**collect_fct**) couples should be unique in that case.

               - (**order**,**on**) couple is optional for all aggregation types.

               - **size** is optional for term and geohash/geotile, and must not be specified for the other types.

               - **include** is optional for term, and must not be specified for the other types.

            - {type} possible values are :

                   datehistogram, histogram, geohash, geotile and term.

            - {interval} possible values depends on {type}.

                   If {type} = datehistogram, then {interval} = {size}(year,quarter,month,week,day,hour,minute,second). Size value must be equal to 1 for year,quarter,month and week unities.

                   If {type} = histogram, then {interval} = {size}.

                   If {type} = geohash, then {interval} = {size}. It's an integer between 1 and 12. Lower the length, greater is the surface of aggregation.

                   If {type} = geotile, then {interval} = {size}. It's an integer corresponding to zoom level of the aggregation, that should be larger than or equal to {z} in the path param, and no bigger than {z}+6.

                   If {type} = term, then interval-{interval} is not needed.

            - format-{format} is the date format for key aggregation. The default value is yyyy-MM-dd-hh:mm:ss.

            - {collect_fct} is the aggregation function to apply to collections on the specified {collect_field}.

              {collect_fct} possible values are :

                   avg,cardinality,max,min,sum

            - {order} is set to sort the aggregation buckets on the field name, on the count of the buckets or on the the result of a metric sub-aggregation. Its values are 'asc' or 'desc'.

            - {on} is set to specify whether the {order} is on the field name, on the count of the aggregation or on the result of a metric sub-aggregation. Its values are 'field', 'count' or 'result'.

            - If {on} is equal to `result` and two or more (**collect_field**,**collect_fct**) couples are specified, then the order is applied on the first `collect_fct` that is different from geobbox and geocentroid

            - {size} Defines how many buckets should be returned.

            - {include} Specifies the values for which buckets will be created. This values are comma separated. If one value is specified then regular expressions can be used (only in this case) and buckets matching them will be created. If more than one value are specified then only buckets matching the exact values will be created.

            - **aggregated_geometries**

                > **What it does**: Allows to specify a list of aggregated forms of geometries that represent the bucket.

                > __**Syntax**__: `aggregated_geometries-{COMMA_SEPARATED_AGGREGATED_GEOMETRIES}`.

                > __**Available aggregated geometries**__: `centroid, bbox, cell, cell_center`.

                   - **centroid**: returns the centroid of data inside the bucket.

                   - **bbox**: returns the data extent (bbox) in each bucket.

                   - **cell**: returns the cell extent (zxy or geohash) of each bucket. This form is supported for **geohash** and **geotile** aggregation type only.

                   - **cell_center**: returns the cell center of each bucket. This form is supported for **geohash** and **geotile** aggregation type only.

                > __**Response**__: the aggregated geometries are returned in `geometries` list in the json response. Each object inside this list has : the reference to the aggregated form, the geojson geometry and an attribute `is_raw` set to false

                > __**Example**__: `aggregated_geometries-bbox,cell`

            - **raw_geometries**

                > **What it does**: Allows to specify a list of raw geometries provided by hits that represent the bucket and that are elected by a sort

                > __**Syntax**__: `raw_geometries-{GEOMETRY_FIELD}({COMMA_SEPERATED_SORT_FIELDS});{GEOMETRY_FIELD2}({COMMA_SEPERATED_SORT_FIELDS2})`.

                > __**Available raw geometries**__: any field of the collection whose type is **geo-point** or **geo-shape**.

                   - sort fields are optional. If no sort is specified, an ascending sort on `collection.params.timestamp_path` is applied

                   - a sort field can be preceded by '-' for descending sort. Otherwise the sort is ascending

                > __**Response**__: the aggregated geometries are returned in `geometries` list in the json response. Each object inside this list has : the reference to the geometry path, the used sort, the geojson geometry and an attribute `is_raw` set to true

                > __**Example**__: `raw_geometries-geo_field1,geo_field2  ||  raw_geometries-geo_field(-field1,field2)` || raw_geometries-geo_field1(field1);geo_field2(field2,field3)

            - **fetch_hits**

                > **What it does**: Specifies the number of hits to retrieve inside each aggregation bucket and which fields to include in the hits.

                > __**Syntax**__: `fetch_hits-{sizeOfHitsToFetch}(+{field1}, {field2}, -{field3}, ...)`.

                > **Note 1**: `{sizeOfHitsToFetch}` is optional, if not specified, 1 is considered as default.

                > **Note 2**: `{field}` can be preceded by **+** or **-** for **ascending** or **descending** sort of the hits. Order matters.

                > __**Example**__: `fetch_hits-3(-timestamp, geometry)`. Fetches the 3 last positions for each bucket.

            **agg** parameter is multiple. Every agg parameter specified is a subaggregation of the previous one : order matters.

          required: true
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: f
          in: query
          description: |-
            - A triplet for filtering the result. Multiple filter can be provided in distinct parameters (AND operator is applied) or in the same parameter separated by semi-colons (OR operator is applied). The order does not matter.

            - A triplet is composed of a field name, a comparison operator and a value.

              The possible values of the comparison operator are :

                   Operator        --                   Description                    -- value type

                   :eq:            -- {fieldName} equals {comma separated values}. **OR** operation is applied for the specified values -- numeric or strings

                   :ne:            -- {fieldName} must not equal {comma separated values }. **AND** operation is applied for the specified values -- numeric or strings

                   :like:          -- {fieldName}  is like {value}                     -- numeric or strings

                   :gte:           -- {fieldName} is greater than or equal to  {value} -- numeric

                   :gt:            -- {fieldName} is greater than {value}              -- numeric

                   :lte:           -- {fieldName} is less than or equal to {value}     -- numeric

                   :lt:            -- {fieldName}  is less than {value}                -- numeric

                   :range:         -- {fieldName} is between `{comma separated [min<max] values}`. **OR** operation is applied for the specified ranges -- numeric or strings. If the field's type is date, then min & max should be timestamps in millisecond or a Date expression

                   :within:        -- {GeofieldName}` is within the `{given WKT string or the given BBOX }` -- a WKT string or the BBOX string : `"west, south, east, north"`

                   :notwithin:     -- {GeofieldName} is not within the `{given WKT string or the given BBOX }` -- a WKT string or the BBOX string : `"west, south, east, north"`

                   :intersects:    -- {GeofieldName} intersects the `{given WKT string or the given BBOX }` | a WKT string or the BBOX string : `"west, south, east, north"`

                   :notintersects: -- {GeofieldName} does not intersect the `{given WKT string or the given }` -- a WKT string or the BBOX string : `"west, south, east, north"`
          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: q
          in: query
          description: 'A full text search. Optionally, it''s possible to search on a field using this syntax: {fieldname}:{text}'
          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: dateformat
          in: query
          description: The format of dates. This parameter should be set only if a date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte` and `range` operations
          required: false
          type: string
        - name: righthand
          in: query
          description: |-
            If righthand = true, the passed WKT should be counter clock-wise; otherwise, geo-analytics service will attempt to parse it as the "Complementary" Polygon on the other facet of the planet.
             Inversely, If righthand = false, the passed WKT should be clock-wise; otherwise, geo-analytics service will attempt to parse it as the "Complementary" Polygon on the other facet of the planet.
          required: false
          type: boolean
          default: true
        - name: pretty
          in: query
          description: Pretty print
          required: false
          type: boolean
          default: false
        - name: flat
          in: query
          description: 'Flats the property map: only key/value on one level'
          required: false
          type: boolean
          default: false
        - name: max-age-cache
          in: query
          description: max-age-cache
          required: false
          type: integer
          format: int32
      responses:
        '200':
          description: Successful operation
          schema:
            $ref: '#/definitions/AggregationResponse'
        '400':
          description: Bad request.
          schema:
            $ref: '#/definitions/Error'
        '500':
          description: Server Error.
          schema:
            $ref: '#/definitions/Error'
    post:
      tags:
        - explore
      summary: Aggregate
      description: Aggregate the elements in the collection(s), given the filters and the aggregation parameters
      operationId: aggregatePost
      consumes:
        - application/json;charset=utf-8
      produces:
        - application/json;charset=utf-8
      parameters:
        - name: collection
          in: path
          description: collection
          required: true
          type: string
        - in: body
          name: body
          required: false
          schema:
            $ref: '#/definitions/AggregationsRequest'
        - name: pretty
          in: query
          description: Pretty print
          required: false
          type: boolean
          default: false
        - name: max-age-cache
          in: query
          description: max-age-cache
          required: false
          type: integer
          format: int32
      responses:
        '200':
          description: Successful operation
          schema:
            $ref: '#/definitions/AggregationResponse'
        '400':
          description: Bad request.
          schema:
            $ref: '#/definitions/Error'
        '500':
          description: Server Error.
          schema:
            $ref: '#/definitions/Error'
  /explore/{collection}/_shapeaggregate:
    get:
      tags:
        - explore
      summary: ShapeAggregate
      description: Aggregate the elements in the collection(s) as features, given the filters and the aggregation parameters, and returns a shapefile of it.
      operationId: shapeaggregate
      consumes:
        - application/json;charset=utf-8
      produces:
        - application/zip
      parameters:
        - name: collection
          in: path
          description: collection
          required: true
          type: string
        - name: agg
          in: query
          description: |-
            - The agg parameter should be given in the following formats:

                   {type}:{field}:interval-{interval}:format-{format}:collect_field-{collect_field}:collect_fct-{function}:order-{order}:on-{on}:size-{size}:raw_geometries-{raw_geometries values}:aggregated_geometries-{aggregated_geometries values}:fetch_hits-{fetch_hits values}

            Where :

               - **{type}:{field}** part is mandatory.

               - **interval** must be specified only when aggregation type is datehistogram, histogram, geotile and geohash.

               - **format** is optional for datehistogram, and must not be specified for the other types.

               - (**collect_field**,**collect_fct**) couple is optional for all aggregation types.

               - (**order**,**on**) couple is optional for all aggregation types.

               - **size** is optional for term and geohash/geotile, and must not be specified for the other types.

               - **include** is optional for term, and must not be specified for the other types.

            - {type} possible values are :

                   geohash, geotile, datehistogram, histogram and term. geohash or geotile must be the main aggregation.

            - {interval} possible values depends on {type}.

                   If {type} = datehistogram, then {interval} = {size}(year,quarter,month,week,day,hour,minute,second). Size value must be equal to 1 for year,quarter,month and week unities.

                   If {type} = histogram, then {interval} = {size}.

                   If {type} = geohash, then {interval} = {size}. It's an integer between 1 and 12. Lower the length, greater is the surface of aggregation.

                   If {type} = geotile, then {interval} = {size}. It's an integer corresponding to zoom level of the aggregation, that should be larger than or equal to {z} in the path param, and no bigger than {z}+6 (max 29).

                   If {type} = term, then interval-{interval} is not needed.

            - format-{format} is the date format for key aggregation. The default value is yyyy-MM-dd-hh:mm:ss.

            - {collect_fct} is the aggregation function to apply to collections on the specified {collect_field}.

              {collect_fct} possible values are :

                   avg,cardinality,max,min,sum,geobbox,geocentroid

            - (collect_field,collect_fct) should both be specified, except when collect_fct = `geobbox` or `geocentroid`, it could be specified alone. The metrics `geobbox` and `geocentroid` are returned as features collections.

            - {order} is set to sort the aggregation buckets on the field name, on the count of the buckets or on the the result of a metric sub-aggregation. Its values are 'asc' or 'desc'.

            - {on} is set to specify whether the {order} is on the field name, on the count of the aggregation or on the result of a metric sub-aggregation. Its values are 'field', 'count' or 'result'.

            - When {on} = `result`, then (collect_field,collect_fct) should be specified. Except when {collect_fct} = `geobbox` or `geocentroid`, then {on}=`result` is prohibited

            - {size} Defines how many buckets should be returned.

            - {include} Specifies the values for which buckets will be created. This values are comma separated. If one value is specified then regular expressions can be used (only in this case) and buckets matching them will be created. If more than one value are specified then only buckets matching the exact values will be created.

            - **aggregated_geometries**

                > **What it does**: Allows to specify a list of aggregated forms of geometries that represent the bucket.

                > __**Syntax**__: `aggregated_geometries-{COMMA_SEPARATED_AGGREGATED_GEOMETRIES}`.

                > __**Available aggregated geometries**__: `centroid, bbox, cell, cell_center`.

                   - **centroid**: returns the centroid of data inside the bucket.

                   - **bbox**: returns the data extent (bbox) in each bucket.

                   - **cell**: returns the cell (zxy or geohash) extent of each bucket. This form is supported for **geohash** and **geotile** aggregation type only.

                   - **cell_center**: returns the cell center of each bucket. This form is supported for **geohash** and **geotile** aggregation type only.

                > __**Response**__: Each bucket of the aggregation will be represented with as many features (in a feature collection) as there are specified aggregated geometries. The properties of each feature has :

                   - **geometry_ref** attribute that informs which aggregated form is returned

                   - **geometry_type** attribute set to *aggregated*

                > __**Example**__: `aggregated_geometries-bbox,geohash`

            - **raw_geometries**

                > **What it does**: Allows to specify a list of raw geometries provided by hits that represent the bucket and that are elected by a sort

                > __**Syntax**__: `raw_geometries-{GEOMETRY_FIELD}({COMMA_SEPERATED_SORT_FIELDS});{GEOMETRY_FIELD2}({COMMA_SEPERATED_SORT_FIELDS2})`.

                > __**Available raw geometries**__: any field of the collection whose type is **geo-point** or **geo-shape**.

                   - sort fields are optional. If no sort is specified, an ascending sort on `collection.params.timestamp_path` is applied

                   - a sort field can be preceded by '-' for descending sort. Otherwise the sort is ascending

                > __**Response**__: each bucket of the aggregation will be represented with as many features (in a feature collection) as there are specified raw geometries. The properties of each feature has :

                   - **geometry_ref** attribute that informs which geometry path is returned

                   - **geometry_type** attribute set to *raw*

                   - **geometry_sort** attribute that informs how the geometry path is fetched (with what sort)

                > __**Example**__: `raw_geometries-geo_field1,geo_field2  ||  raw_geometries-geo_field(-field1,field2)` || raw_geometries-geo_field1(field1);geo_field2(field2,field3)

            - **fetch_hits**

                > **What it does**: Specifies the number of hits to retrieve inside each aggregation bucket and which fields to include in the hits.

                > __**Syntax**__: `fetch_hits-{sizeOfHitsToFetch}(+{field1}, {field2}, -{field3}, ...)`.

                > **Note 1**: `{sizeOfHitsToFetch}` is optional, if not specified, 1 is considered as default.

                > **Note 2**: `{field}` can be preceded by **+** or **-** for **ascending** or **descending** sort of the hits. Order matters.

                > __**Example**__: `fetch_hits-3(-timestamp, geometry)`. Fetches the 3 last positions for each bucket.

            **agg** parameter is multiple. The first (main) aggregation must be geohash or geotile. Every agg parameter specified is a subaggregation of the previous one : order matters.

          required: true
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: f
          in: query
          description: |-
            - A triplet for filtering the result. Multiple filter can be provided in distinct parameters (AND operator is applied) or in the same parameter separated by semi-colons (OR operator is applied). The order does not matter.

            - A triplet is composed of a field name, a comparison operator and a value.

              The possible values of the comparison operator are :

                   Operator        --                   Description                    -- value type

                   :eq:            -- {fieldName} equals {comma separated values}. **OR** operation is applied for the specified values -- numeric or strings

                   :ne:            -- {fieldName} must not equal {comma separated values }. **AND** operation is applied for the specified values -- numeric or strings

                   :like:          -- {fieldName}  is like {value}                     -- numeric or strings

                   :gte:           -- {fieldName} is greater than or equal to  {value} -- numeric

                   :gt:            -- {fieldName} is greater than {value}              -- numeric

                   :lte:           -- {fieldName} is less than or equal to {value}     -- numeric

                   :lt:            -- {fieldName}  is less than {value}                -- numeric

                   :range:         -- {fieldName} is between `{comma separated [min<max] values}`. **OR** operation is applied for the specified ranges -- numeric or strings. If the field's type is date, then min & max should be timestamps in millisecond or a Date expression

                   :within:        -- {GeofieldName}` is within the `{given WKT string or the given BBOX }` -- a WKT string or the BBOX string : `"west, south, east, north"`

                   :notwithin:     -- {GeofieldName} is not within the `{given WKT string or the given BBOX }` -- a WKT string or the BBOX string : `"west, south, east, north"`

                   :intersects:    -- {GeofieldName} intersects the `{given WKT string or the given BBOX }` | a WKT string or the BBOX string : `"west, south, east, north"`

                   :notintersects: -- {GeofieldName} does not intersect the `{given WKT string or the given }` -- a WKT string or the BBOX string : `"west, south, east, north"`
          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: q
          in: query
          description: 'A full text search. Optionally, it''s possible to search on a field using this syntax: {fieldname}:{text}'
          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: dateformat
          in: query
          description: The format of dates. This parameter should be set only if a date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte` and `range` operations
          required: false
          type: string
        - name: righthand
          in: query
          description: |-
            If righthand = true, the passed WKT should be counter clock-wise; otherwise, geo-analytics service will attempt to parse it as the "Complementary" Polygon on the other facet of the planet.
             Inversely, If righthand = false, the passed WKT should be clock-wise; otherwise, geo-analytics service will attempt to parse it as the "Complementary" Polygon on the other facet of the planet.
          required: false
          type: boolean
          default: true
        - name: pretty
          in: query
          description: Pretty print
          required: false
          type: boolean
          default: false
        - name: max-age-cache
          in: query
          description: max-age-cache
          required: false
          type: integer
          format: int32
      responses:
        '200':
          description: Successful operation
        '400':
          description: Bad request.
          schema:
            $ref: '#/definitions/Error'
        '500':
          description: Server Error.
          schema:
            $ref: '#/definitions/Error'
        '501':
          description: Not implemented functionality.
          schema:
            $ref: '#/definitions/Error'
    post:
      tags:
        - explore
      summary: ShapeAggregate
      description: Aggregate the elements in the collection(s) as features, given the filters and the aggregation parameters, and returns a shapefile of it.
      operationId: shapeaggregatePost
      consumes:
        - application/json;charset=utf-8
      produces:
        - application/zip
      parameters:
        - name: collection
          in: path
          description: collection
          required: true
          type: string
        - in: body
          name: body
          required: false
          schema:
            $ref: '#/definitions/AggregationsRequest'
        - name: pretty
          in: query
          description: Pretty print
          required: false
          type: boolean
          default: false
        - name: max-age-cache
          in: query
          description: max-age-cache
          required: false
          type: integer
          format: int32
      responses:
        '200':
          description: Successful operation
        '400':
          description: Bad request.
          schema:
            $ref: '#/definitions/Error'
        '500':
          description: Server Error.
          schema:
            $ref: '#/definitions/Error'
        '501':
          description: Not implemented functionality.
          schema:
            $ref: '#/definitions/Error'
  /explore/{collection}/_geoaggregate/{geohash}:
    get:
      tags:
        - explore
      summary: GeoAggregate on a geohash
      description: Aggregate the elements in the collection(s) and localized in the given geohash as features, given the filters and the aggregation parameters.
      operationId: geohashgeoaggregate
      consumes:
        - application/json;charset=utf-8
      produces:
        - application/json;charset=utf-8
      parameters:
        - name: collection
          in: path
          description: collection
          required: true
          type: string
        - name: geohash
          in: path
          description: geohash
          required: true
          type: string
        - name: agg
          in: query
          description: |-
            - The agg parameter should be given in the following formats:

                   {type}:{field}:interval-{interval}:format-{format}:collect_field-{collect_field}:collect_fct-{function}:order-{order}:on-{on}:size-{size}:raw_geometries-{raw_geometries values}:aggregated_geometries-{aggregated_geometries values}:fetch_hits-{fetch_hits values}

            Where :

               - **{type}:{field}** part is mandatory.

               - **interval** must be specified only when aggregation type is datehistogram, histogram, geotile and geohash.

               - **format** is optional for datehistogram, and must not be specified for the other types.

               - (**collect_field**,**collect_fct**) couple is optional for all aggregation types.

               - (**order**,**on**) couple is optional for all aggregation types.

               - **size** is optional for term and geohash/geotile, and must not be specified for the other types.

               - **include** is optional for term, and must not be specified for the other types.

            - {type} possible values are :

                   geohash, geotile, datehistogram, histogram and term. geohash or geotile must be the main aggregation.

            - {interval} possible values depends on {type}.

                   If {type} = datehistogram, then {interval} = {size}(year,quarter,month,week,day,hour,minute,second). Size value must be equal to 1 for year,quarter,month and week unities.

                   If {type} = histogram, then {interval} = {size}.

                   If {type} = geohash, then {interval} = {size}. It's an integer between 1 and 12. Lower the length, greater is the surface of aggregation.

                   If {type} = geotile, then {interval} = {size}. It's an integer corresponding to zoom level of the aggregation, that should be larger than or equal to {z} in the path param, and no bigger than {z}+6 (max 29).

                   If {type} = term, then interval-{interval} is not needed.

            - format-{format} is the date format for key aggregation. The default value is yyyy-MM-dd-hh:mm:ss.

            - {collect_fct} is the aggregation function to apply to collections on the specified {collect_field}.

              {collect_fct} possible values are :

                   avg,cardinality,max,min,sum,geobbox,geocentroid

            - (collect_field,collect_fct) should both be specified, except when collect_fct = `geobbox` or `geocentroid`, it could be specified alone. The metrics `geobbox` and `geocentroid` are returned as features collections.

            - {order} is set to sort the aggregation buckets on the field name, on the count of the buckets or on the the result of a metric sub-aggregation. Its values are 'asc' or 'desc'.

            - {on} is set to specify whether the {order} is on the field name, on the count of the aggregation or on the result of a metric sub-aggregation. Its values are 'field', 'count' or 'result'.

            - When {on} = `result`, then (collect_field,collect_fct) should be specified. Except when {collect_fct} = `geobbox` or `geocentroid`, then {on}=`result` is prohibited

            - {size} Defines how many buckets should be returned.

            - {include} Specifies the values for which buckets will be created. This values are comma separated. If one value is specified then regular expressions can be used (only in this case) and buckets matching them will be created. If more than one value are specified then only buckets matching the exact values will be created.

            - **aggregated_geometries**

                > **What it does**: Allows to specify a list of aggregated forms of geometries that represent the bucket.

                > __**Syntax**__: `aggregated_geometries-{COMMA_SEPARATED_AGGREGATED_GEOMETRIES}`.

                > __**Available aggregated geometries**__: `centroid, bbox, cell, cell_center`.

                   - **centroid**: returns the centroid of data inside the bucket.

                   - **bbox**: returns the data extent (bbox) in each bucket.

                   - **cell**: returns the cell (zxy or geohash) extent of each bucket. This form is supported for **geohash** and **geotile** aggregation type only.

                   - **cell_center**: returns the cell center of each bucket. This form is supported for **geohash** and **geotile** aggregation type only.

                > __**Response**__: Each bucket of the aggregation will be represented with as many features (in a feature collection) as there are specified aggregated geometries. The properties of each feature has :

                   - **geometry_ref** attribute that informs which aggregated form is returned

                   - **geometry_type** attribute set to *aggregated*

                > __**Example**__: `aggregated_geometries-bbox,geohash`

            - **raw_geometries**

                > **What it does**: Allows to specify a list of raw geometries provided by hits that represent the bucket and that are elected by a sort

                > __**Syntax**__: `raw_geometries-{GEOMETRY_FIELD}({COMMA_SEPERATED_SORT_FIELDS});{GEOMETRY_FIELD2}({COMMA_SEPERATED_SORT_FIELDS2})`.

                > __**Available raw geometries**__: any field of the collection whose type is **geo-point** or **geo-shape**.

                   - sort fields are optional. If no sort is specified, an ascending sort on `collection.params.timestamp_path` is applied

                   - a sort field can be preceded by '-' for descending sort. Otherwise the sort is ascending

                > __**Response**__: each bucket of the aggregation will be represented with as many features (in a feature collection) as there are specified raw geometries. The properties of each feature has :

                   - **geometry_ref** attribute that informs which geometry path is returned

                   - **geometry_type** attribute set to *raw*

                   - **geometry_sort** attribute that informs how the geometry path is fetched (with what sort)

                > __**Example**__: `raw_geometries-geo_field1,geo_field2  ||  raw_geometries-geo_field(-field1,field2)` || raw_geometries-geo_field1(field1);geo_field2(field2,field3)

            - **fetch_hits**

                > **What it does**: Specifies the number of hits to retrieve inside each aggregation bucket and which fields to include in the hits.

                > __**Syntax**__: `fetch_hits-{sizeOfHitsToFetch}(+{field1}, {field2}, -{field3}, ...)`.

                > **Note 1**: `{sizeOfHitsToFetch}` is optional, if not specified, 1 is considered as default.

                > **Note 2**: `{field}` can be preceded by **+** or **-** for **ascending** or **descending** sort of the hits. Order matters.

                > __**Example**__: `fetch_hits-3(-timestamp, geometry)`. Fetches the 3 last positions for each bucket.

            **agg** parameter is multiple. The first (main) aggregation must be geohash or geotile. Every agg parameter specified is a subaggregation of the previous one : order matters.

          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: f
          in: query
          description: |-
            - A triplet for filtering the result. Multiple filter can be provided in distinct parameters (AND operator is applied) or in the same parameter separated by semi-colons (OR operator is applied). The order does not matter.

            - A triplet is composed of a field name, a comparison operator and a value.

              The possible values of the comparison operator are :

                   Operator        --                   Description                    -- value type

                   :eq:            -- {fieldName} equals {comma separated values}. **OR** operation is applied for the specified values -- numeric or strings

                   :ne:            -- {fieldName} must not equal {comma separated values }. **AND** operation is applied for the specified values -- numeric or strings

                   :like:          -- {fieldName}  is like {value}                     -- numeric or strings

                   :gte:           -- {fieldName} is greater than or equal to  {value} -- numeric

                   :gt:            -- {fieldName} is greater than {value}              -- numeric

                   :lte:           -- {fieldName} is less than or equal to {value}     -- numeric

                   :lt:            -- {fieldName}  is less than {value}                -- numeric

                   :range:         -- {fieldName} is between `{comma separated [min<max] values}`. **OR** operation is applied for the specified ranges -- numeric or strings. If the field's type is date, then min & max should be timestamps in millisecond or a Date expression

                   :within:        -- {GeofieldName}` is within the `{given WKT string or the given BBOX }` -- a WKT string or the BBOX string : `"west, south, east, north"`

                   :notwithin:     -- {GeofieldName} is not within the `{given WKT string or the given BBOX }` -- a WKT string or the BBOX string : `"west, south, east, north"`

                   :intersects:    -- {GeofieldName} intersects the `{given WKT string or the given BBOX }` | a WKT string or the BBOX string : `"west, south, east, north"`

                   :notintersects: -- {GeofieldName} does not intersect the `{given WKT string or the given }` -- a WKT string or the BBOX string : `"west, south, east, north"`
          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: q
          in: query
          description: 'A full text search. Optionally, it''s possible to search on a field using this syntax: {fieldname}:{text}'
          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: dateformat
          in: query
          description: The format of dates. This parameter should be set only if a date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte` and `range` operations
          required: false
          type: string
        - name: righthand
          in: query
          description: |-
            If righthand = true, the passed WKT should be counter clock-wise; otherwise, geo-analytics service will attempt to parse it as the "Complementary" Polygon on the other facet of the planet.
             Inversely, If righthand = false, the passed WKT should be clock-wise; otherwise, geo-analytics service will attempt to parse it as the "Complementary" Polygon on the other facet of the planet.
          required: false
          type: boolean
          default: true
        - name: pretty
          in: query
          description: Pretty print
          required: false
          type: boolean
          default: false
        - name: flat
          in: query
          description: 'Flats the property map: only key/value on one level'
          required: false
          type: boolean
          default: false
        - name: max-age-cache
          in: query
          description: max-age-cache
          required: false
          type: integer
          format: int32
      responses:
        '200':
          description: Successful operation
          schema:
            $ref: '#/definitions/FeatureCollection'
        '400':
          description: Bad request.
          schema:
            $ref: '#/definitions/Error'
        '500':
          description: Server Error.
          schema:
            $ref: '#/definitions/Error'
        '501':
          description: Not implemented functionality.
          schema:
            $ref: '#/definitions/Error'
  /explore/{collection}/_geoaggregate/{z}/{x}/{y}:
    get:
      tags:
        - explore
      summary: GeoAggregate on a geotile
      description: Aggregate the elements in the collection(s) and localized in the given tile as features, given the filters and the aggregation parameters.
      operationId: geotilegeoaggregate
      consumes:
        - application/json;charset=utf-8
      produces:
        - application/json;charset=utf-8
      parameters:
        - name: collection
          in: path
          description: collection
          required: true
          type: string
        - name: z
          in: path
          description: z
          required: true
          type: integer
          format: int32
        - name: x
          in: path
          description: x
          required: true
          type: integer
          format: int32
        - name: 'y'
          in: path
          description: 'y'
          required: true
          type: integer
          format: int32
        - name: agg
          in: query
          description: |-
            - The agg parameter should be given in the following formats:

                   {type}:{field}:interval-{interval}:format-{format}:collect_field-{collect_field}:collect_fct-{function}:order-{order}:on-{on}:size-{size}:raw_geometries-{raw_geometries values}:aggregated_geometries-{aggregated_geometries values}:fetch_hits-{fetch_hits values}

            Where :

               - **{type}:{field}** part is mandatory.

               - **interval** must be specified only when aggregation type is datehistogram, histogram, geotile and geohash.

               - **format** is optional for datehistogram, and must not be specified for the other types.

               - (**collect_field**,**collect_fct**) couple is optional for all aggregation types.

               - (**order**,**on**) couple is optional for all aggregation types.

               - **size** is optional for term and geohash/geotile, and must not be specified for the other types.

               - **include** is optional for term, and must not be specified for the other types.

            - {type} possible values are :

                   geohash, geotile, datehistogram, histogram and term. geohash or geotile must be the main aggregation.

            - {interval} possible values depends on {type}.

                   If {type} = datehistogram, then {interval} = {size}(year,quarter,month,week,day,hour,minute,second). Size value must be equal to 1 for year,quarter,month and week unities.

                   If {type} = histogram, then {interval} = {size}.

                   If {type} = geohash, then {interval} = {size}. It's an integer between 1 and 12. Lower the length, greater is the surface of aggregation.

                   If {type} = geotile, then {interval} = {size}. It's an integer corresponding to zoom level of the aggregation, that should be larger than or equal to {z} in the path param, and no bigger than {z}+6 (max 29).

                   If {type} = term, then interval-{interval} is not needed.

            - format-{format} is the date format for key aggregation. The default value is yyyy-MM-dd-hh:mm:ss.

            - {collect_fct} is the aggregation function to apply to collections on the specified {collect_field}.

              {collect_fct} possible values are :

                   avg,cardinality,max,min,sum,geobbox,geocentroid

            - (collect_field,collect_fct) should both be specified, except when collect_fct = `geobbox` or `geocentroid`, it could be specified alone. The metrics `geobbox` and `geocentroid` are returned as features collections.

            - {order} is set to sort the aggregation buckets on the field name, on the count of the buckets or on the the result of a metric sub-aggregation. Its values are 'asc' or 'desc'.

            - {on} is set to specify whether the {order} is on the field name, on the count of the aggregation or on the result of a metric sub-aggregation. Its values are 'field', 'count' or 'result'.

            - When {on} = `result`, then (collect_field,collect_fct) should be specified. Except when {collect_fct} = `geobbox` or `geocentroid`, then {on}=`result` is prohibited

            - {size} Defines how many buckets should be returned.

            - {include} Specifies the values for which buckets will be created. This values are comma separated. If one value is specified then regular expressions can be used (only in this case) and buckets matching them will be created. If more than one value are specified then only buckets matching the exact values will be created.

            - **aggregated_geometries**

                > **What it does**: Allows to specify a list of aggregated forms of geometries that represent the bucket.

                > __**Syntax**__: `aggregated_geometries-{COMMA_SEPARATED_AGGREGATED_GEOMETRIES}`.

                > __**Available aggregated geometries**__: `centroid, bbox, cell, cell_center`.

                   - **centroid**: returns the centroid of data inside the bucket.

                   - **bbox**: returns the data extent (bbox) in each bucket.

                   - **cell**: returns the cell (zxy or geohash) extent of each bucket. This form is supported for **geohash** and **geotile** aggregation type only.

                   - **cell_center**: returns the cell center of each bucket. This form is supported for **geohash** and **geotile** aggregation type only.

                > __**Response**__: Each bucket of the aggregation will be represented with as many features (in a feature collection) as there are specified aggregated geometries. The properties of each feature has :

                   - **geometry_ref** attribute that informs which aggregated form is returned

                   - **geometry_type** attribute set to *aggregated*

                > __**Example**__: `aggregated_geometries-bbox,geohash`

            - **raw_geometries**

                > **What it does**: Allows to specify a list of raw geometries provided by hits that represent the bucket and that are elected by a sort

                > __**Syntax**__: `raw_geometries-{GEOMETRY_FIELD}({COMMA_SEPERATED_SORT_FIELDS});{GEOMETRY_FIELD2}({COMMA_SEPERATED_SORT_FIELDS2})`.

                > __**Available raw geometries**__: any field of the collection whose type is **geo-point** or **geo-shape**.

                   - sort fields are optional. If no sort is specified, an ascending sort on `collection.params.timestamp_path` is applied

                   - a sort field can be preceded by '-' for descending sort. Otherwise the sort is ascending

                > __**Response**__: each bucket of the aggregation will be represented with as many features (in a feature collection) as there are specified raw geometries. The properties of each feature has :

                   - **geometry_ref** attribute that informs which geometry path is returned

                   - **geometry_type** attribute set to *raw*

                   - **geometry_sort** attribute that informs how the geometry path is fetched (with what sort)

                > __**Example**__: `raw_geometries-geo_field1,geo_field2  ||  raw_geometries-geo_field(-field1,field2)` || raw_geometries-geo_field1(field1);geo_field2(field2,field3)

            - **fetch_hits**

                > **What it does**: Specifies the number of hits to retrieve inside each aggregation bucket and which fields to include in the hits.

                > __**Syntax**__: `fetch_hits-{sizeOfHitsToFetch}(+{field1}, {field2}, -{field3}, ...)`.

                > **Note 1**: `{sizeOfHitsToFetch}` is optional, if not specified, 1 is considered as default.

                > **Note 2**: `{field}` can be preceded by **+** or **-** for **ascending** or **descending** sort of the hits. Order matters.

                > __**Example**__: `fetch_hits-3(-timestamp, geometry)`. Fetches the 3 last positions for each bucket.

            **agg** parameter is multiple. The first (main) aggregation must be geohash or geotile. Every agg parameter specified is a subaggregation of the previous one : order matters.

          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: f
          in: query
          description: |-
            - A triplet for filtering the result. Multiple filter can be provided in distinct parameters (AND operator is applied) or in the same parameter separated by semi-colons (OR operator is applied). The order does not matter.

            - A triplet is composed of a field name, a comparison operator and a value.

              The possible values of the comparison operator are :

                   Operator        --                   Description                    -- value type

                   :eq:            -- {fieldName} equals {comma separated values}. **OR** operation is applied for the specified values -- numeric or strings

                   :ne:            -- {fieldName} must not equal {comma separated values }. **AND** operation is applied for the specified values -- numeric or strings

                   :like:          -- {fieldName}  is like {value}                     -- numeric or strings

                   :gte:           -- {fieldName} is greater than or equal to  {value} -- numeric

                   :gt:            -- {fieldName} is greater than {value}              -- numeric

                   :lte:           -- {fieldName} is less than or equal to {value}     -- numeric

                   :lt:            -- {fieldName}  is less than {value}                -- numeric

                   :range:         -- {fieldName} is between `{comma separated [min<max] values}`. **OR** operation is applied for the specified ranges -- numeric or strings. If the field's type is date, then min & max should be timestamps in millisecond or a Date expression

                   :within:        -- {GeofieldName}` is within the `{given WKT string or the given BBOX }` -- a WKT string or the BBOX string : `"west, south, east, north"`

                   :notwithin:     -- {GeofieldName} is not within the `{given WKT string or the given BBOX }` -- a WKT string or the BBOX string : `"west, south, east, north"`

                   :intersects:    -- {GeofieldName} intersects the `{given WKT string or the given BBOX }` | a WKT string or the BBOX string : `"west, south, east, north"`

                   :notintersects: -- {GeofieldName} does not intersect the `{given WKT string or the given }` -- a WKT string or the BBOX string : `"west, south, east, north"`
          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: q
          in: query
          description: 'A full text search. Optionally, it''s possible to search on a field using this syntax: {fieldname}:{text}'
          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: dateformat
          in: query
          description: The format of dates. This parameter should be set only if a date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte` and `range` operations
          required: false
          type: string
        - name: righthand
          in: query
          description: |-
            If righthand = true, the passed WKT should be counter clock-wise; otherwise, geo-analytics service will attempt to parse it as the "Complementary" Polygon on the other facet of the planet.
             Inversely, If righthand = false, the passed WKT should be clock-wise; otherwise, geo-analytics service will attempt to parse it as the "Complementary" Polygon on the other facet of the planet.
          required: false
          type: boolean
          default: true
        - name: pretty
          in: query
          description: Pretty print
          required: false
          type: boolean
          default: false
        - name: flat
          in: query
          description: 'Flats the property map: only key/value on one level'
          required: false
          type: boolean
          default: false
        - name: max-age-cache
          in: query
          description: max-age-cache
          required: false
          type: integer
          format: int32
      responses:
        '200':
          description: Successful operation
          schema:
            $ref: '#/definitions/FeatureCollection'
        '400':
          description: Bad request.
          schema:
            $ref: '#/definitions/Error'
        '500':
          description: Server Error.
          schema:
            $ref: '#/definitions/Error'
        '501':
          description: Not implemented functionality.
          schema:
            $ref: '#/definitions/Error'
  /explore/{collection}/_geoaggregate:
    get:
      tags:
        - explore
      summary: GeoAggregate
      description: Aggregate the elements in the collection(s) as features, given the filters and the aggregation parameters.
      operationId: geoaggregate
      consumes:
        - application/json;charset=utf-8
      produces:
        - application/json;charset=utf-8
      parameters:
        - name: collection
          in: path
          description: collection
          required: true
          type: string
        - name: agg
          in: query
          description: |-
            - The agg parameter should be given in the following formats:

                   {type}:{field}:interval-{interval}:format-{format}:collect_field-{collect_field}:collect_fct-{function}:order-{order}:on-{on}:size-{size}:raw_geometries-{raw_geometries values}:aggregated_geometries-{aggregated_geometries values}:fetch_hits-{fetch_hits values}

            Where :

               - **{type}:{field}** part is mandatory.

               - **interval** must be specified only when aggregation type is datehistogram, histogram, geotile and geohash.

               - **format** is optional for datehistogram, and must not be specified for the other types.

               - (**collect_field**,**collect_fct**) couple is optional for all aggregation types.

               - (**order**,**on**) couple is optional for all aggregation types.

               - **size** is optional for term and geohash/geotile, and must not be specified for the other types.

               - **include** is optional for term, and must not be specified for the other types.

            - {type} possible values are :

                   geohash, geotile, datehistogram, histogram and term. geohash or geotile must be the main aggregation.

            - {interval} possible values depends on {type}.

                   If {type} = datehistogram, then {interval} = {size}(year,quarter,month,week,day,hour,minute,second). Size value must be equal to 1 for year,quarter,month and week unities.

                   If {type} = histogram, then {interval} = {size}.

                   If {type} = geohash, then {interval} = {size}. It's an integer between 1 and 12. Lower the length, greater is the surface of aggregation.

                   If {type} = geotile, then {interval} = {size}. It's an integer corresponding to zoom level of the aggregation, that should be larger than or equal to {z} in the path param, and no bigger than {z}+6 (max 29).

                   If {type} = term, then interval-{interval} is not needed.

            - format-{format} is the date format for key aggregation. The default value is yyyy-MM-dd-hh:mm:ss.

            - {collect_fct} is the aggregation function to apply to collections on the specified {collect_field}.

              {collect_fct} possible values are :

                   avg,cardinality,max,min,sum,geobbox,geocentroid

            - (collect_field,collect_fct) should both be specified, except when collect_fct = `geobbox` or `geocentroid`, it could be specified alone. The metrics `geobbox` and `geocentroid` are returned as features collections.

            - {order} is set to sort the aggregation buckets on the field name, on the count of the buckets or on the the result of a metric sub-aggregation. Its values are 'asc' or 'desc'.

            - {on} is set to specify whether the {order} is on the field name, on the count of the aggregation or on the result of a metric sub-aggregation. Its values are 'field', 'count' or 'result'.

            - When {on} = `result`, then (collect_field,collect_fct) should be specified. Except when {collect_fct} = `geobbox` or `geocentroid`, then {on}=`result` is prohibited

            - {size} Defines how many buckets should be returned.

            - {include} Specifies the values for which buckets will be created. This values are comma separated. If one value is specified then regular expressions can be used (only in this case) and buckets matching them will be created. If more than one value are specified then only buckets matching the exact values will be created.

            - **aggregated_geometries**

                > **What it does**: Allows to specify a list of aggregated forms of geometries that represent the bucket.

                > __**Syntax**__: `aggregated_geometries-{COMMA_SEPARATED_AGGREGATED_GEOMETRIES}`.

                > __**Available aggregated geometries**__: `centroid, bbox, cell, cell_center`.

                   - **centroid**: returns the centroid of data inside the bucket.

                   - **bbox**: returns the data extent (bbox) in each bucket.

                   - **cell**: returns the cell (zxy or geohash) extent of each bucket. This form is supported for **geohash** and **geotile** aggregation type only.

                   - **cell_center**: returns the cell center of each bucket. This form is supported for **geohash** and **geotile** aggregation type only.

                > __**Response**__: Each bucket of the aggregation will be represented with as many features (in a feature collection) as there are specified aggregated geometries. The properties of each feature has :

                   - **geometry_ref** attribute that informs which aggregated form is returned

                   - **geometry_type** attribute set to *aggregated*

                > __**Example**__: `aggregated_geometries-bbox,geohash`

            - **raw_geometries**

                > **What it does**: Allows to specify a list of raw geometries provided by hits that represent the bucket and that are elected by a sort

                > __**Syntax**__: `raw_geometries-{GEOMETRY_FIELD}({COMMA_SEPERATED_SORT_FIELDS});{GEOMETRY_FIELD2}({COMMA_SEPERATED_SORT_FIELDS2})`.

                > __**Available raw geometries**__: any field of the collection whose type is **geo-point** or **geo-shape**.

                   - sort fields are optional. If no sort is specified, an ascending sort on `collection.params.timestamp_path` is applied

                   - a sort field can be preceded by '-' for descending sort. Otherwise the sort is ascending

                > __**Response**__: each bucket of the aggregation will be represented with as many features (in a feature collection) as there are specified raw geometries. The properties of each feature has :

                   - **geometry_ref** attribute that informs which geometry path is returned

                   - **geometry_type** attribute set to *raw*

                   - **geometry_sort** attribute that informs how the geometry path is fetched (with what sort)

                > __**Example**__: `raw_geometries-geo_field1,geo_field2  ||  raw_geometries-geo_field(-field1,field2)` || raw_geometries-geo_field1(field1);geo_field2(field2,field3)

            - **fetch_hits**

                > **What it does**: Specifies the number of hits to retrieve inside each aggregation bucket and which fields to include in the hits.

                > __**Syntax**__: `fetch_hits-{sizeOfHitsToFetch}(+{field1}, {field2}, -{field3}, ...)`.

                > **Note 1**: `{sizeOfHitsToFetch}` is optional, if not specified, 1 is considered as default.

                > **Note 2**: `{field}` can be preceded by **+** or **-** for **ascending** or **descending** sort of the hits. Order matters.

                > __**Example**__: `fetch_hits-3(-timestamp, geometry)`. Fetches the 3 last positions for each bucket.

            **agg** parameter is multiple. The first (main) aggregation must be geohash or geotile. Every agg parameter specified is a subaggregation of the previous one : order matters.

          required: true
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: f
          in: query
          description: |-
            - A triplet for filtering the result. Multiple filter can be provided in distinct parameters (AND operator is applied) or in the same parameter separated by semi-colons (OR operator is applied). The order does not matter.

            - A triplet is composed of a field name, a comparison operator and a value.

              The possible values of the comparison operator are :

                   Operator        --                   Description                    -- value type

                   :eq:            -- {fieldName} equals {comma separated values}. **OR** operation is applied for the specified values -- numeric or strings

                   :ne:            -- {fieldName} must not equal {comma separated values }. **AND** operation is applied for the specified values -- numeric or strings

                   :like:          -- {fieldName}  is like {value}                     -- numeric or strings

                   :gte:           -- {fieldName} is greater than or equal to  {value} -- numeric

                   :gt:            -- {fieldName} is greater than {value}              -- numeric

                   :lte:           -- {fieldName} is less than or equal to {value}     -- numeric

                   :lt:            -- {fieldName}  is less than {value}                -- numeric

                   :range:         -- {fieldName} is between `{comma separated [min<max] values}`. **OR** operation is applied for the specified ranges -- numeric or strings. If the field's type is date, then min & max should be timestamps in millisecond or a Date expression

                   :within:        -- {GeofieldName}` is within the `{given WKT string or the given BBOX }` -- a WKT string or the BBOX string : `"west, south, east, north"`

                   :notwithin:     -- {GeofieldName} is not within the `{given WKT string or the given BBOX }` -- a WKT string or the BBOX string : `"west, south, east, north"`

                   :intersects:    -- {GeofieldName} intersects the `{given WKT string or the given BBOX }` | a WKT string or the BBOX string : `"west, south, east, north"`

                   :notintersects: -- {GeofieldName} does not intersect the `{given WKT string or the given }` -- a WKT string or the BBOX string : `"west, south, east, north"`
          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: q
          in: query
          description: 'A full text search. Optionally, it''s possible to search on a field using this syntax: {fieldname}:{text}'
          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: dateformat
          in: query
          description: The format of dates. This parameter should be set only if a date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte` and `range` operations
          required: false
          type: string
        - name: righthand
          in: query
          description: |-
            If righthand = true, the passed WKT should be counter clock-wise; otherwise, geo-analytics service will attempt to parse it as the "Complementary" Polygon on the other facet of the planet.
             Inversely, If righthand = false, the passed WKT should be clock-wise; otherwise, geo-analytics service will attempt to parse it as the "Complementary" Polygon on the other facet of the planet.
          required: false
          type: boolean
          default: true
        - name: pretty
          in: query
          description: Pretty print
          required: false
          type: boolean
          default: false
        - name: flat
          in: query
          description: 'Flats the property map: only key/value on one level'
          required: false
          type: boolean
          default: false
        - name: max-age-cache
          in: query
          description: max-age-cache
          required: false
          type: integer
          format: int32
      responses:
        '200':
          description: Successful operation
          schema:
            $ref: '#/definitions/FeatureCollection'
        '400':
          description: Bad request.
          schema:
            $ref: '#/definitions/Error'
        '500':
          description: Server Error.
          schema:
            $ref: '#/definitions/Error'
        '501':
          description: Not implemented functionality.
          schema:
            $ref: '#/definitions/Error'
    post:
      tags:
        - explore
      summary: GeoAggregate
      description: Aggregate the elements in the collection(s) as features, given the filters and the aggregation parameters.
      operationId: geoaggregatePost
      consumes:
        - application/json;charset=utf-8
      produces:
        - application/json;charset=utf-8
      parameters:
        - name: collection
          in: path
          description: collection
          required: true
          type: string
        - in: body
          name: body
          required: false
          schema:
            $ref: '#/definitions/AggregationsRequest'
        - name: pretty
          in: query
          description: Pretty print
          required: false
          type: boolean
          default: false
        - name: max-age-cache
          in: query
          description: max-age-cache
          required: false
          type: integer
          format: int32
      responses:
        '200':
          description: Successful operation
          schema:
            $ref: '#/definitions/FeatureCollection'
        '400':
          description: Bad request.
          schema:
            $ref: '#/definitions/Error'
        '500':
          description: Server Error.
          schema:
            $ref: '#/definitions/Error'
        '501':
          description: Not implemented functionality.
          schema:
            $ref: '#/definitions/Error'
  /explore/{collection}/_compute:
    get:
      tags:
        - explore
      summary: Compute
      description: Computes the given metric on a field in the collection, given the filters
      operationId: compute
      consumes:
        - application/json;charset=utf-8
      produces:
        - application/json;charset=utf-8
      parameters:
        - name: collection
          in: path
          description: collection
          required: true
          type: string
        - name: field
          in: query
          description: The field on which the metric is calculated.
          required: true
          type: string
        - name: metric
          in: query
          description: 'The metric to compute : `max, min, avg, sum, cardinality, spanning, geobbox, geocentroid`.'
          required: true
          type: string
        - name: f
          in: query
          description: |-
            - A triplet for filtering the result. Multiple filter can be provided in distinct parameters (AND operator is applied) or in the same parameter separated by semi-colons (OR operator is applied). The order does not matter.

            - A triplet is composed of a field name, a comparison operator and a value.

              The possible values of the comparison operator are :

                   Operator        --                   Description                    -- value type

                   :eq:            -- {fieldName} equals {comma separated values}. **OR** operation is applied for the specified values -- numeric or strings

                   :ne:            -- {fieldName} must not equal {comma separated values }. **AND** operation is applied for the specified values -- numeric or strings

                   :like:          -- {fieldName}  is like {value}                     -- numeric or strings

                   :gte:           -- {fieldName} is greater than or equal to  {value} -- numeric

                   :gt:            -- {fieldName} is greater than {value}              -- numeric

                   :lte:           -- {fieldName} is less than or equal to {value}     -- numeric

                   :lt:            -- {fieldName}  is less than {value}                -- numeric

                   :range:         -- {fieldName} is between `{comma separated [min<max] values}`. **OR** operation is applied for the specified ranges -- numeric or strings. If the field's type is date, then min & max should be timestamps in millisecond or a Date expression

                   :within:        -- {GeofieldName}` is within the `{given WKT string or the given BBOX }` -- a WKT string or the BBOX string : `"west, south, east, north"`

                   :notwithin:     -- {GeofieldName} is not within the `{given WKT string or the given BBOX }` -- a WKT string or the BBOX string : `"west, south, east, north"`

                   :intersects:    -- {GeofieldName} intersects the `{given WKT string or the given BBOX }` | a WKT string or the BBOX string : `"west, south, east, north"`

                   :notintersects: -- {GeofieldName} does not intersect the `{given WKT string or the given }` -- a WKT string or the BBOX string : `"west, south, east, north"`
          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: q
          in: query
          description: 'A full text search. Optionally, it''s possible to search on a field using this syntax: {fieldname}:{text}'
          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: dateformat
          in: query
          description: The format of dates. This parameter should be set only if a date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte` and `range` operations
          required: false
          type: string
        - name: righthand
          in: query
          description: |-
            If righthand = true, the passed WKT should be counter clock-wise; otherwise, geo-analytics service will attempt to parse it as the "Complementary" Polygon on the other facet of the planet.
             Inversely, If righthand = false, the passed WKT should be clock-wise; otherwise, geo-analytics service will attempt to parse it as the "Complementary" Polygon on the other facet of the planet.
          required: false
          type: boolean
          default: true
        - name: pretty
          in: query
          description: Pretty print
          required: false
          type: boolean
          default: false
        - name: max-age-cache
          in: query
          description: max-age-cache
          required: false
          type: integer
          format: int32
      responses:
        '200':
          description: Successful operation
          schema:
            $ref: '#/definitions/ComputationResponse'
        '400':
          description: Bad request.
          schema:
            $ref: '#/definitions/Error'
        '500':
          description: Server Error.
          schema:
            $ref: '#/definitions/Error'
    post:
      tags:
        - explore
      summary: Compute
      description: Computes the given metric on a field in the collection, given the filters
      operationId: computePost
      consumes:
        - application/json;charset=utf-8
      produces:
        - application/json;charset=utf-8
      parameters:
        - name: collection
          in: path
          description: collection
          required: true
          type: string
        - in: body
          name: body
          required: false
          schema:
            $ref: '#/definitions/ComputationRequest'
        - name: pretty
          in: query
          description: Pretty print
          required: false
          type: boolean
          default: false
        - name: max-age-cache
          in: query
          description: max-age-cache
          required: false
          type: integer
          format: int32
      responses:
        '200':
          description: Successful operation
          schema:
            $ref: '#/definitions/ComputationResponse'
        '400':
          description: Bad request.
          schema:
            $ref: '#/definitions/Error'
        '500':
          description: Server Error.
          schema:
            $ref: '#/definitions/Error'
  /explore/{collection}/_count:
    get:
      tags:
        - explore
      summary: Count
      description: Count the number of elements found in the collection(s), given the filters
      operationId: count
      consumes:
        - application/json;charset=utf-8
      produces:
        - application/json;charset=utf-8
      parameters:
        - name: collection
          in: path
          description: collections
          required: true
          type: string
        - name: f
          in: query
          description: |-
            - A triplet for filtering the result. Multiple filter can be provided in distinct parameters (AND operator is applied) or in the same parameter separated by semi-colons (OR operator is applied). The order does not matter.

            - A triplet is composed of a field name, a comparison operator and a value.

              The possible values of the comparison operator are :

                   Operator        --                   Description                    -- value type

                   :eq:            -- {fieldName} equals {comma separated values}. **OR** operation is applied for the specified values -- numeric or strings

                   :ne:            -- {fieldName} must not equal {comma separated values }. **AND** operation is applied for the specified values -- numeric or strings

                   :like:          -- {fieldName}  is like {value}                     -- numeric or strings

                   :gte:           -- {fieldName} is greater than or equal to  {value} -- numeric

                   :gt:            -- {fieldName} is greater than {value}              -- numeric

                   :lte:           -- {fieldName} is less than or equal to {value}     -- numeric

                   :lt:            -- {fieldName}  is less than {value}                -- numeric

                   :range:         -- {fieldName} is between `{comma separated [min<max] values}`. **OR** operation is applied for the specified ranges -- numeric or strings. If the field's type is date, then min & max should be timestamps in millisecond or a Date expression

                   :within:        -- {GeofieldName}` is within the `{given WKT string or the given BBOX }` -- a WKT string or the BBOX string : `"west, south, east, north"`

                   :notwithin:     -- {GeofieldName} is not within the `{given WKT string or the given BBOX }` -- a WKT string or the BBOX string : `"west, south, east, north"`

                   :intersects:    -- {GeofieldName} intersects the `{given WKT string or the given BBOX }` | a WKT string or the BBOX string : `"west, south, east, north"`

                   :notintersects: -- {GeofieldName} does not intersect the `{given WKT string or the given }` -- a WKT string or the BBOX string : `"west, south, east, north"`
          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: q
          in: query
          description: 'A full text search. Optionally, it''s possible to search on a field using this syntax: {fieldname}:{text}'
          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: dateformat
          in: query
          description: The format of dates. This parameter should be set only if a date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte` and `range` operations
          required: false
          type: string
        - name: righthand
          in: query
          description: |-
            If righthand = true, the passed WKT should be counter clock-wise; otherwise, geo-analytics service will attempt to parse it as the "Complementary" Polygon on the other facet of the planet.
             Inversely, If righthand = false, the passed WKT should be clock-wise; otherwise, geo-analytics service will attempt to parse it as the "Complementary" Polygon on the other facet of the planet.
          required: false
          type: boolean
          default: true
        - name: pretty
          in: query
          description: Pretty print
          required: false
          type: boolean
          default: false
        - name: max-age-cache
          in: query
          description: max-age-cache
          required: false
          type: integer
          format: int32
      responses:
        '200':
          description: Successful operation
          schema:
            $ref: '#/definitions/Hits'
        '400':
          description: Bad request.
          schema:
            $ref: '#/definitions/Error'
        '500':
          description: Server Error.
          schema:
            $ref: '#/definitions/Error'
    post:
      tags:
        - explore
      summary: Count
      description: Count the number of elements found in the collection(s), given the filters
      operationId: countPost
      consumes:
        - application/json;charset=utf-8
      produces:
        - application/json;charset=utf-8
      parameters:
        - name: collection
          in: path
          description: collections
          required: true
          type: string
        - name: pretty
          in: query
          description: Pretty print
          required: false
          type: boolean
          default: false
        - in: body
          name: body
          required: false
          schema:
            $ref: '#/definitions/Count'
      responses:
        '200':
          description: Successful operation
          schema:
            $ref: '#/definitions/Hits'
        '400':
          description: Bad request.
          schema:
            $ref: '#/definitions/Error'
        '500':
          description: Server Error.
          schema:
            $ref: '#/definitions/Error'
  /explore/{collection}/_describe:
    get:
      tags:
        - explore
      summary: Describe
      description: 'Describe the structure and the content of the given collection. '
      operationId: describe
      consumes:
        - application/json;charset=utf-8
      produces:
        - application/json;charset=utf-8
      parameters:
        - name: collection
          in: path
          description: collection
          required: true
          type: string
        - name: pretty
          in: query
          description: Pretty print
          required: false
          type: boolean
          default: false
        - name: max-age-cache
          in: query
          description: max-age-cache
          required: false
          type: integer
          format: int32
      responses:
        '200':
          description: Successful operation
          schema:
            $ref: '#/definitions/CollectionReferenceDescription'
        '400':
          description: Bad request.
          schema:
            $ref: '#/definitions/Error'
        '500':
          description: Server Error.
          schema:
            $ref: '#/definitions/Error'
  /explore/_list:
    get:
      tags:
        - explore
      summary: List
      description: 'List the collections configured. '
      operationId: list
      consumes:
        - application/json;charset=utf-8
      produces:
        - application/json;charset=utf-8
      parameters:
        - name: pretty
          in: query
          description: Pretty print
          required: false
          type: boolean
          default: false
        - name: max-age-cache
          in: query
          description: max-age-cache
          required: false
          type: integer
          format: int32
      responses:
        '200':
          description: Successful operation
          schema:
            type: array
            items:
              $ref: '#/definitions/CollectionReferenceDescription'
        '400':
          description: Bad request.
          schema:
            $ref: '#/definitions/Error'
        '500':
          description: Server Error.
          schema:
            $ref: '#/definitions/Error'
  /explore/{collection}/{identifier}:
    get:
      tags:
        - explore
      summary: Get a raw document
      description: Returns a raw indexed document.
      operationId: getHit
      consumes:
        - application/json;charset=utf-8
      produces:
        - application/json;charset=utf-8
      parameters:
        - name: collection
          in: path
          description: collection
          required: true
          type: string
        - name: identifier
          in: path
          description: identifier
          required: true
          type: string
        - name: pretty
          in: query
          description: Pretty print
          required: false
          type: boolean
          default: false
        - name: flat
          in: query
          description: 'Flats the property map: only key/value on one level'
          required: false
          type: boolean
          default: false
        - name: max-age-cache
          in: query
          description: max-age-cache
          required: false
          type: integer
          format: int32
      responses:
        '200':
          description: Successful operation
          schema:
            $ref: '#/definitions/Hit'
        '400':
          description: Bad request.
          schema:
            $ref: '#/definitions/Error'
        '404':
          description: Not Found Error.
          schema:
            $ref: '#/definitions/Error'
        '500':
          description: Server Error.
          schema:
            $ref: '#/definitions/Error'
  /explore/{collection}/_geosearch/{z}/{x}/{y}:
    get:
      tags:
        - explore
      summary: Tiled GeoSearch
      description: Search and return the elements found in the collection(s) and localized in the given tile(x,y,z) as features, given the filters
      operationId: tiledgeosearch
      consumes:
        - application/json;charset=utf-8
      produces:
        - application/json;charset=utf-8
      parameters:
        - name: collection
          in: path
          description: collection
          required: true
          type: string
        - name: x
          in: path
          description: x
          required: true
          type: integer
          format: int32
        - name: 'y'
          in: path
          description: 'y'
          required: true
          type: integer
          format: int32
        - name: z
          in: path
          description: z
          required: true
          type: integer
          format: int32
        - name: f
          in: query
          description: |-
            - A triplet for filtering the result. Multiple filter can be provided in distinct parameters (AND operator is applied) or in the same parameter separated by semi-colons (OR operator is applied). The order does not matter.

            - A triplet is composed of a field name, a comparison operator and a value.

              The possible values of the comparison operator are :

                   Operator        --                   Description                    -- value type

                   :eq:            -- {fieldName} equals {comma separated values}. **OR** operation is applied for the specified values -- numeric or strings

                   :ne:            -- {fieldName} must not equal {comma separated values }. **AND** operation is applied for the specified values -- numeric or strings

                   :like:          -- {fieldName}  is like {value}                     -- numeric or strings

                   :gte:           -- {fieldName} is greater than or equal to  {value} -- numeric

                   :gt:            -- {fieldName} is greater than {value}              -- numeric

                   :lte:           -- {fieldName} is less than or equal to {value}     -- numeric

                   :lt:            -- {fieldName}  is less than {value}                -- numeric

                   :range:         -- {fieldName} is between `{comma separated [min<max] values}`. **OR** operation is applied for the specified ranges -- numeric or strings. If the field's type is date, then min & max should be timestamps in millisecond or a Date expression

                   :within:        -- {GeofieldName}` is within the `{given WKT string or the given BBOX }` -- a WKT string or the BBOX string : `"west, south, east, north"`

                   :notwithin:     -- {GeofieldName} is not within the `{given WKT string or the given BBOX }` -- a WKT string or the BBOX string : `"west, south, east, north"`

                   :intersects:    -- {GeofieldName} intersects the `{given WKT string or the given BBOX }` | a WKT string or the BBOX string : `"west, south, east, north"`

                   :notintersects: -- {GeofieldName} does not intersect the `{given WKT string or the given }` -- a WKT string or the BBOX string : `"west, south, east, north"`
          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: q
          in: query
          description: 'A full text search. Optionally, it''s possible to search on a field using this syntax: {fieldname}:{text}'
          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: dateformat
          in: query
          description: The format of dates. This parameter should be set only if a date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte` and `range` operations
          required: false
          type: string
        - name: righthand
          in: query
          description: |-
            If righthand = true, the passed WKT should be counter clock-wise; otherwise, geo-analytics service will attempt to parse it as the "Complementary" Polygon on the other facet of the planet.
             Inversely, If righthand = false, the passed WKT should be clock-wise; otherwise, geo-analytics service will attempt to parse it as the "Complementary" Polygon on the other facet of the planet.
          required: false
          type: boolean
          default: true
        - name: pretty
          in: query
          description: Pretty print
          required: false
          type: boolean
          default: false
        - name: flat
          in: query
          description: 'Flats the property map: only key/value on one level'
          required: false
          type: boolean
          default: false
        - name: include
          in: query
          description: List the name patterns of the field to be included in the result. Separate patterns with a comma.
          required: false
          type: array
          items:
            type: string
            default: '*'
          collectionFormat: multi
        - name: exclude
          in: query
          description: List the name patterns of the field to be excluded in the result. Separate patterns with a comma.
          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: returned_geometries
          in: query
          description: Comma separated geometry field_paths to be included in the result. If not specified, only geometry_path is returned. If geometry_path is null, then centroid_path is returned
          required: false
          type: string
        - name: size
          in: query
          description: The maximum number of entries or sub-entries to be returned. The default value is 10
          required: false
          type: integer
          default: 10
          minimum: 1
        - name: from
          in: query
          description: From index to start the search from. Defaults to 0.
          required: false
          type: integer
          default: 0
          minimum: 0
        - name: sort
          in: query
          description: |
            Sorts the resulted hits on the given fields and/or by distance to a given point:

            > __**Syntax**__: `{field1},{field2},-{field3},geodistance:{lat} {lon},{field4}  ...`.

            > **Note 1**: `{field}` can be preceded by **'-'**  for **descending** sort. By default, sort is ascending.

            > **Note 2**: The order of fields matters.

            > **Note 3** ***geodistance sort***: Sorts the hits centroids by distance to the given **{lat} {lon}** (ascending distance sort). It can be specified at most 1 time.

            > __**Example 1**__: sort=`age,-timestamp`. Resulted hits are sorted by age. For same age hits, they are decreasingly sorted in time.

            > __**Example 2**__: sort=`age,geodistance:89 179`. Resulted hits are sorted by age. For same age hits, they are sorted by closest distance to the point(89,179)

          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: after
          in: query
          description: |
            List of values of fields present in sort param that are used to search after.

            > **What it does**: Retrieve the data placed after the pointed element, given the provided order (sort).

            > __**Restriction 1**__: **after** param works only combined with **sort** param.

            > __**Syntax**__: `after={value1},{value2},...,{valueN} & sort={field1},{field2},...,{fieldN}`.

            > **Note 1**: *{value1}` and `{value2}` are the values of `{field1}` and `{field2}` in the last hit returned in the previous search

            > **Note 2**: The order of fields and values matters. *{value1},{value2}* must be in the same order of *{field1},{field2}* in **sort** param

            > **Note 3**:  The last field `{fieldN}` must be the id field specified in the collection **collection.params.idPath** (returned as **md.id**) and `{valueN}` its corresponding value.

            > __**Example**__: *sort=`-date,id` & **after**=`01/02/2019,abcd1234`*. Gets the following hits of the previous search that stopped at date *01/02/2019* and id *abcd1234*.

            > __**Restriction 2**__: **from** param must be set to 0 or kept unset

          required: false
          type: string
        - name: before
          in: query
          description: Same idea that after param, but to retrieve the data placed before the pointed element, given the provided order (sort).
          required: false
          type: string
        - name: max-age-cache
          in: query
          description: max-age-cache
          required: false
          type: integer
          format: int32
      responses:
        '200':
          description: Successful operation
          schema:
            $ref: '#/definitions/FeatureCollection'
        '400':
          description: Bad request.
          schema:
            $ref: '#/definitions/Error'
        '500':
          description: Server Error.
          schema:
            $ref: '#/definitions/Error'
  /explore/{collection}/_shapesearch:
    get:
      tags:
        - explore
      summary: ShapeSearch
      description: Search and return the elements found in the collection(s) as features, given the filters, exported as a Shapefile
      operationId: shapesearch
      consumes:
        - application/json;charset=utf-8
      produces:
        - application/zip
      parameters:
        - name: collection
          in: path
          description: collection
          required: true
          type: string
        - name: f
          in: query
          description: |-
            - A triplet for filtering the result. Multiple filter can be provided in distinct parameters (AND operator is applied) or in the same parameter separated by semi-colons (OR operator is applied). The order does not matter.

            - A triplet is composed of a field name, a comparison operator and a value.

              The possible values of the comparison operator are :

                   Operator        --                   Description                    -- value type

                   :eq:            -- {fieldName} equals {comma separated values}. **OR** operation is applied for the specified values -- numeric or strings

                   :ne:            -- {fieldName} must not equal {comma separated values }. **AND** operation is applied for the specified values -- numeric or strings

                   :like:          -- {fieldName}  is like {value}                     -- numeric or strings

                   :gte:           -- {fieldName} is greater than or equal to  {value} -- numeric

                   :gt:            -- {fieldName} is greater than {value}              -- numeric

                   :lte:           -- {fieldName} is less than or equal to {value}     -- numeric

                   :lt:            -- {fieldName}  is less than {value}                -- numeric

                   :range:         -- {fieldName} is between `{comma separated [min<max] values}`. **OR** operation is applied for the specified ranges -- numeric or strings. If the field's type is date, then min & max should be timestamps in millisecond or a Date expression

                   :within:        -- {GeofieldName}` is within the `{given WKT string or the given BBOX }` -- a WKT string or the BBOX string : `"west, south, east, north"`

                   :notwithin:     -- {GeofieldName} is not within the `{given WKT string or the given BBOX }` -- a WKT string or the BBOX string : `"west, south, east, north"`

                   :intersects:    -- {GeofieldName} intersects the `{given WKT string or the given BBOX }` | a WKT string or the BBOX string : `"west, south, east, north"`

                   :notintersects: -- {GeofieldName} does not intersect the `{given WKT string or the given }` -- a WKT string or the BBOX string : `"west, south, east, north"`
          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: q
          in: query
          description: 'A full text search. Optionally, it''s possible to search on a field using this syntax: {fieldname}:{text}'
          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: dateformat
          in: query
          description: The format of dates. This parameter should be set only if a date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte` and `range` operations
          required: false
          type: string
        - name: righthand
          in: query
          description: |-
            If righthand = true, the passed WKT should be counter clock-wise; otherwise, geo-analytics service will attempt to parse it as the "Complementary" Polygon on the other facet of the planet.
             Inversely, If righthand = false, the passed WKT should be clock-wise; otherwise, geo-analytics service will attempt to parse it as the "Complementary" Polygon on the other facet of the planet.
          required: false
          type: boolean
          default: true
        - name: pretty
          in: query
          description: Pretty print
          required: false
          type: boolean
          default: false
        - name: include
          in: query
          description: List the name patterns of the field to be included in the result. Separate patterns with a comma.
          required: false
          type: array
          items:
            type: string
            default: '*'
          collectionFormat: multi
        - name: exclude
          in: query
          description: List the name patterns of the field to be excluded in the result. Separate patterns with a comma.
          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: returned_geometries
          in: query
          description: Comma separated geometry field_paths to be included in the result. If not specified, only geometry_path is returned. If geometry_path is null, then centroid_path is returned
          required: false
          type: string
        - name: size
          in: query
          description: The maximum number of entries or sub-entries to be returned. The default value is 10
          required: false
          type: integer
          default: 10
          minimum: 1
        - name: from
          in: query
          description: From index to start the search from. Defaults to 0.
          required: false
          type: integer
          default: 0
          minimum: 0
        - name: sort
          in: query
          description: |
            Sorts the resulted hits on the given fields and/or by distance to a given point:

            > __**Syntax**__: `{field1},{field2},-{field3},geodistance:{lat} {lon},{field4}  ...`.

            > **Note 1**: `{field}` can be preceded by **'-'**  for **descending** sort. By default, sort is ascending.

            > **Note 2**: The order of fields matters.

            > **Note 3** ***geodistance sort***: Sorts the hits centroids by distance to the given **{lat} {lon}** (ascending distance sort). It can be specified at most 1 time.

            > __**Example 1**__: sort=`age,-timestamp`. Resulted hits are sorted by age. For same age hits, they are decreasingly sorted in time.

            > __**Example 2**__: sort=`age,geodistance:89 179`. Resulted hits are sorted by age. For same age hits, they are sorted by closest distance to the point(89,179)

          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: after
          in: query
          description: |
            List of values of fields present in sort param that are used to search after.

            > **What it does**: Retrieve the data placed after the pointed element, given the provided order (sort).

            > __**Restriction 1**__: **after** param works only combined with **sort** param.

            > __**Syntax**__: `after={value1},{value2},...,{valueN} & sort={field1},{field2},...,{fieldN}`.

            > **Note 1**: *{value1}` and `{value2}` are the values of `{field1}` and `{field2}` in the last hit returned in the previous search

            > **Note 2**: The order of fields and values matters. *{value1},{value2}* must be in the same order of *{field1},{field2}* in **sort** param

            > **Note 3**:  The last field `{fieldN}` must be the id field specified in the collection **collection.params.idPath** (returned as **md.id**) and `{valueN}` its corresponding value.

            > __**Example**__: *sort=`-date,id` & **after**=`01/02/2019,abcd1234`*. Gets the following hits of the previous search that stopped at date *01/02/2019* and id *abcd1234*.

            > __**Restriction 2**__: **from** param must be set to 0 or kept unset

          required: false
          type: string
        - name: before
          in: query
          description: Same idea that after param, but to retrieve the data placed before the pointed element, given the provided order (sort).
          required: false
          type: string
        - name: max-age-cache
          in: query
          description: max-age-cache
          required: false
          type: integer
          format: int32
      responses:
        '200':
          description: Successful operation
        '400':
          description: Bad request.
          schema:
            $ref: '#/definitions/Error'
        '500':
          description: Server Error.
          schema:
            $ref: '#/definitions/Error'
    post:
      tags:
        - explore
      summary: ShapeSearch
      description: Search and return the elements found in the collection(s) as features, given the filters, exported as a Shapefile
      operationId: shapesearchPost
      consumes:
        - application/json;charset=utf-8
      produces:
        - application/zip
      parameters:
        - name: collection
          in: path
          description: collection
          required: true
          type: string
        - in: body
          name: body
          required: false
          schema:
            $ref: '#/definitions/Search'
        - name: pretty
          in: query
          description: Pretty print
          required: false
          type: boolean
          default: false
        - name: max-age-cache
          in: query
          description: max-age-cache
          required: false
          type: integer
          format: int32
      responses:
        '200':
          description: Successful operation
        '400':
          description: Bad request.
          schema:
            $ref: '#/definitions/Error'
        '500':
          description: Server Error.
          schema:
            $ref: '#/definitions/Error'
  /explore/{collection}/_geosearch:
    get:
      tags:
        - explore
      summary: GeoSearch
      description: Search and return the elements found in the collection(s) as features, given the filters
      operationId: geosearch
      consumes:
        - application/json;charset=utf-8
      produces:
        - application/json;charset=utf-8
      parameters:
        - name: collection
          in: path
          description: collection
          required: true
          type: string
        - name: f
          in: query
          description: |-
            - A triplet for filtering the result. Multiple filter can be provided in distinct parameters (AND operator is applied) or in the same parameter separated by semi-colons (OR operator is applied). The order does not matter.

            - A triplet is composed of a field name, a comparison operator and a value.

              The possible values of the comparison operator are :

                   Operator        --                   Description                    -- value type

                   :eq:            -- {fieldName} equals {comma separated values}. **OR** operation is applied for the specified values -- numeric or strings

                   :ne:            -- {fieldName} must not equal {comma separated values }. **AND** operation is applied for the specified values -- numeric or strings

                   :like:          -- {fieldName}  is like {value}                     -- numeric or strings

                   :gte:           -- {fieldName} is greater than or equal to  {value} -- numeric

                   :gt:            -- {fieldName} is greater than {value}              -- numeric

                   :lte:           -- {fieldName} is less than or equal to {value}     -- numeric

                   :lt:            -- {fieldName}  is less than {value}                -- numeric

                   :range:         -- {fieldName} is between `{comma separated [min<max] values}`. **OR** operation is applied for the specified ranges -- numeric or strings. If the field's type is date, then min & max should be timestamps in millisecond or a Date expression

                   :within:        -- {GeofieldName}` is within the `{given WKT string or the given BBOX }` -- a WKT string or the BBOX string : `"west, south, east, north"`

                   :notwithin:     -- {GeofieldName} is not within the `{given WKT string or the given BBOX }` -- a WKT string or the BBOX string : `"west, south, east, north"`

                   :intersects:    -- {GeofieldName} intersects the `{given WKT string or the given BBOX }` | a WKT string or the BBOX string : `"west, south, east, north"`

                   :notintersects: -- {GeofieldName} does not intersect the `{given WKT string or the given }` -- a WKT string or the BBOX string : `"west, south, east, north"`
          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: q
          in: query
          description: 'A full text search. Optionally, it''s possible to search on a field using this syntax: {fieldname}:{text}'
          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: dateformat
          in: query
          description: The format of dates. This parameter should be set only if a date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte` and `range` operations
          required: false
          type: string
        - name: righthand
          in: query
          description: |-
            If righthand = true, the passed WKT should be counter clock-wise; otherwise, geo-analytics service will attempt to parse it as the "Complementary" Polygon on the other facet of the planet.
             Inversely, If righthand = false, the passed WKT should be clock-wise; otherwise, geo-analytics service will attempt to parse it as the "Complementary" Polygon on the other facet of the planet.
          required: false
          type: boolean
          default: true
        - name: pretty
          in: query
          description: Pretty print
          required: false
          type: boolean
          default: false
        - name: flat
          in: query
          description: 'Flats the property map: only key/value on one level'
          required: false
          type: boolean
          default: false
        - name: include
          in: query
          description: List the name patterns of the field to be included in the result. Separate patterns with a comma.
          required: false
          type: array
          items:
            type: string
            default: '*'
          collectionFormat: multi
        - name: exclude
          in: query
          description: List the name patterns of the field to be excluded in the result. Separate patterns with a comma.
          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: returned_geometries
          in: query
          description: Comma separated geometry field_paths to be included in the result. If not specified, only geometry_path is returned. If geometry_path is null, then centroid_path is returned
          required: false
          type: string
        - name: size
          in: query
          description: The maximum number of entries or sub-entries to be returned. The default value is 10
          required: false
          type: integer
          default: 10
          minimum: 1
        - name: from
          in: query
          description: From index to start the search from. Defaults to 0.
          required: false
          type: integer
          default: 0
          minimum: 0
        - name: sort
          in: query
          description: |
            Sorts the resulted hits on the given fields and/or by distance to a given point:

            > __**Syntax**__: `{field1},{field2},-{field3},geodistance:{lat} {lon},{field4}  ...`.

            > **Note 1**: `{field}` can be preceded by **'-'**  for **descending** sort. By default, sort is ascending.

            > **Note 2**: The order of fields matters.

            > **Note 3** ***geodistance sort***: Sorts the hits centroids by distance to the given **{lat} {lon}** (ascending distance sort). It can be specified at most 1 time.

            > __**Example 1**__: sort=`age,-timestamp`. Resulted hits are sorted by age. For same age hits, they are decreasingly sorted in time.

            > __**Example 2**__: sort=`age,geodistance:89 179`. Resulted hits are sorted by age. For same age hits, they are sorted by closest distance to the point(89,179)

          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: after
          in: query
          description: |
            List of values of fields present in sort param that are used to search after.

            > **What it does**: Retrieve the data placed after the pointed element, given the provided order (sort).

            > __**Restriction 1**__: **after** param works only combined with **sort** param.

            > __**Syntax**__: `after={value1},{value2},...,{valueN} & sort={field1},{field2},...,{fieldN}`.

            > **Note 1**: *{value1}` and `{value2}` are the values of `{field1}` and `{field2}` in the last hit returned in the previous search

            > **Note 2**: The order of fields and values matters. *{value1},{value2}* must be in the same order of *{field1},{field2}* in **sort** param

            > **Note 3**:  The last field `{fieldN}` must be the id field specified in the collection **collection.params.idPath** (returned as **md.id**) and `{valueN}` its corresponding value.

            > __**Example**__: *sort=`-date,id` & **after**=`01/02/2019,abcd1234`*. Gets the following hits of the previous search that stopped at date *01/02/2019* and id *abcd1234*.

            > __**Restriction 2**__: **from** param must be set to 0 or kept unset

          required: false
          type: string
        - name: before
          in: query
          description: Same idea that after param, but to retrieve the data placed before the pointed element, given the provided order (sort).
          required: false
          type: string
        - name: max-age-cache
          in: query
          description: max-age-cache
          required: false
          type: integer
          format: int32
      responses:
        '200':
          description: Successful operation
          schema:
            $ref: '#/definitions/FeatureCollection'
        '400':
          description: Bad request.
          schema:
            $ref: '#/definitions/Error'
        '500':
          description: Server Error.
          schema:
            $ref: '#/definitions/Error'
    post:
      tags:
        - explore
      summary: GeoSearch
      description: Search and return the elements found in the collection(s) as features, given the filters
      operationId: geosearchPost
      consumes:
        - application/json;charset=utf-8
      produces:
        - application/json;charset=utf-8
      parameters:
        - name: collection
          in: path
          description: collection
          required: true
          type: string
        - in: body
          name: body
          required: false
          schema:
            $ref: '#/definitions/Search'
        - name: pretty
          in: query
          description: Pretty print
          required: false
          type: boolean
          default: false
        - name: max-age-cache
          in: query
          description: max-age-cache
          required: false
          type: integer
          format: int32
      responses:
        '200':
          description: Successful operation
          schema:
            $ref: '#/definitions/FeatureCollection'
        '400':
          description: Bad request.
          schema:
            $ref: '#/definitions/Error'
        '500':
          description: Server Error.
          schema:
            $ref: '#/definitions/Error'
  /explore/{collection}/_search:
    get:
      tags:
        - explore
      summary: Search
      description: Search and return the elements found in the collection, given the filters
      operationId: search
      consumes:
        - application/json;charset=utf-8
      produces:
        - application/json;charset=utf-8
        - application/atom+xml
      parameters:
        - name: collection
          in: path
          description: collection
          required: true
          type: string
        - name: f
          in: query
          description: |-
            - A triplet for filtering the result. Multiple filter can be provided in distinct parameters (AND operator is applied) or in the same parameter separated by semi-colons (OR operator is applied). The order does not matter.

            - A triplet is composed of a field name, a comparison operator and a value.

              The possible values of the comparison operator are :

                   Operator        --                   Description                    -- value type

                   :eq:            -- {fieldName} equals {comma separated values}. **OR** operation is applied for the specified values -- numeric or strings

                   :ne:            -- {fieldName} must not equal {comma separated values }. **AND** operation is applied for the specified values -- numeric or strings

                   :like:          -- {fieldName}  is like {value}                     -- numeric or strings

                   :gte:           -- {fieldName} is greater than or equal to  {value} -- numeric

                   :gt:            -- {fieldName} is greater than {value}              -- numeric

                   :lte:           -- {fieldName} is less than or equal to {value}     -- numeric

                   :lt:            -- {fieldName}  is less than {value}                -- numeric

                   :range:         -- {fieldName} is between `{comma separated [min<max] values}`. **OR** operation is applied for the specified ranges -- numeric or strings. If the field's type is date, then min & max should be timestamps in millisecond or a Date expression

                   :within:        -- {GeofieldName}` is within the `{given WKT string or the given BBOX }` -- a WKT string or the BBOX string : `"west, south, east, north"`

                   :notwithin:     -- {GeofieldName} is not within the `{given WKT string or the given BBOX }` -- a WKT string or the BBOX string : `"west, south, east, north"`

                   :intersects:    -- {GeofieldName} intersects the `{given WKT string or the given BBOX }` | a WKT string or the BBOX string : `"west, south, east, north"`

                   :notintersects: -- {GeofieldName} does not intersect the `{given WKT string or the given }` -- a WKT string or the BBOX string : `"west, south, east, north"`
          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: q
          in: query
          description: 'A full text search. Optionally, it''s possible to search on a field using this syntax: {fieldname}:{text}'
          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: dateformat
          in: query
          description: The format of dates. This parameter should be set only if a date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte` and `range` operations
          required: false
          type: string
        - name: righthand
          in: query
          description: |-
            If righthand = true, the passed WKT should be counter clock-wise; otherwise, geo-analytics service will attempt to parse it as the "Complementary" Polygon on the other facet of the planet.
             Inversely, If righthand = false, the passed WKT should be clock-wise; otherwise, geo-analytics service will attempt to parse it as the "Complementary" Polygon on the other facet of the planet.
          required: false
          type: boolean
          default: true
        - name: pretty
          in: query
          description: Pretty print
          required: false
          type: boolean
          default: false
        - name: flat
          in: query
          description: 'Flats the property map: only key/value on one level'
          required: false
          type: boolean
          default: false
        - name: include
          in: query
          description: List the name patterns of the field to be included in the result. Separate patterns with a comma.
          required: false
          type: array
          items:
            type: string
            default: '*'
          collectionFormat: multi
        - name: exclude
          in: query
          description: List the name patterns of the field to be excluded in the result. Separate patterns with a comma.
          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: returned_geometries
          in: query
          description: Comma separated geometry field_paths to be included in the result. If not specified, only geometry_path is returned. If geometry_path is null, then centroid_path is returned
          required: false
          type: string
        - name: size
          in: query
          description: The maximum number of entries or sub-entries to be returned. The default value is 10
          required: false
          type: integer
          default: 10
          minimum: 1
        - name: from
          in: query
          description: From index to start the search from. Defaults to 0.
          required: false
          type: integer
          default: 0
          minimum: 0
        - name: sort
          in: query
          description: |
            Sorts the resulted hits on the given fields and/or by distance to a given point:

            > __**Syntax**__: `{field1},{field2},-{field3},geodistance:{lat} {lon},{field4}  ...`.

            > **Note 1**: `{field}` can be preceded by **'-'**  for **descending** sort. By default, sort is ascending.

            > **Note 2**: The order of fields matters.

            > **Note 3** ***geodistance sort***: Sorts the hits centroids by distance to the given **{lat} {lon}** (ascending distance sort). It can be specified at most 1 time.

            > __**Example 1**__: sort=`age,-timestamp`. Resulted hits are sorted by age. For same age hits, they are decreasingly sorted in time.

            > __**Example 2**__: sort=`age,geodistance:89 179`. Resulted hits are sorted by age. For same age hits, they are sorted by closest distance to the point(89,179)

          required: false
          type: string
        - name: after
          in: query
          description: |
            List of values of fields present in sort param that are used to search after.

            > **What it does**: Retrieve the data placed after the pointed element, given the provided order (sort).

            > __**Restriction 1**__: **after** param works only combined with **sort** param.

            > __**Syntax**__: `after={value1},{value2},...,{valueN} & sort={field1},{field2},...,{fieldN}`.

            > **Note 1**: *{value1}` and `{value2}` are the values of `{field1}` and `{field2}` in the last hit returned in the previous search

            > **Note 2**: The order of fields and values matters. *{value1},{value2}* must be in the same order of *{field1},{field2}* in **sort** param

            > **Note 3**:  The last field `{fieldN}` must be the id field specified in the collection **collection.params.idPath** (returned as **md.id**) and `{valueN}` its corresponding value.

            > __**Example**__: *sort=`-date,id` & **after**=`01/02/2019,abcd1234`*. Gets the following hits of the previous search that stopped at date *01/02/2019* and id *abcd1234*.

            > __**Restriction 2**__: **from** param must be set to 0 or kept unset

          required: false
          type: string
        - name: before
          in: query
          description: Same idea that after param, but to retrieve the data placed before the pointed element, given the provided order (sort).
          required: false
          type: string
        - name: max-age-cache
          in: query
          description: max-age-cache
          required: false
          type: integer
          format: int32
      responses:
        '200':
          description: Successful operation
          schema:
            $ref: '#/definitions/Hits'
        '400':
          description: Bad request.
          schema:
            $ref: '#/definitions/Error'
        '500':
          description: Server Error.
          schema:
            $ref: '#/definitions/Error'
    post:
      tags:
        - explore
      summary: Search
      description: Search and return the elements found in the collection, given the filters
      operationId: searchPost
      consumes:
        - application/json;charset=utf-8
      produces:
        - application/json;charset=utf-8
      parameters:
        - name: collection
          in: path
          description: collection
          required: true
          type: string
        - in: body
          name: body
          required: false
          schema:
            $ref: '#/definitions/Search'
        - name: pretty
          in: query
          description: Pretty print
          required: false
          type: boolean
          default: false
        - name: max-age-cache
          in: query
          description: max-age-cache
          required: false
          type: integer
          format: int32
      responses:
        '200':
          description: Successful operation
          schema:
            $ref: '#/definitions/Hits'
        '400':
          description: Bad request.
          schema:
            $ref: '#/definitions/Error'
        '500':
          description: Server Error.
          schema:
            $ref: '#/definitions/Error'
  /explore/{collections}/_suggest:
    get:
      tags:
        - explore
      summary: Suggest
      description: Suggest the the n (n=size) most relevant terms given the filters
      operationId: suggest
      consumes:
        - application/json;charset=utf-8
      produces:
        - application/json;charset=utf-8
      parameters:
        - name: collections
          in: path
          description: collections, comma separated
          required: true
          type: string
        - name: f
          in: query
          description: |-
            - A triplet for filtering the result. Multiple filter can be provided. The order does not matter.

            - A triplet is composed of a field name, a comparison operator and a value.

              The possible values of the comparison operator are :

                   Operator   |                   Description                      | value type

                   :          |  {fieldName} equals {value}                        | numeric or strings

                   :gte:      |  {fieldName} is greater than or equal to  {value}  | numeric

                   :gt:       |  {fieldName} is greater than {value}               | numeric

                   :lte:      |  {fieldName} is less than or equal to {value}      | numeric

                   :lt:       |  {fieldName}  is less than {value}                 | numeric



            - The AND operator is applied between filters having different fieldNames.

            - The OR operator is applied on filters having the same fieldName.

            - If the fieldName starts with - then a must not filter is used

            - If the fieldName starts with - then a must not filter is used

          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: q
          in: query
          description: A full text search
          required: false
          type: string
        - name: pretty
          in: query
          description: Pretty print
          required: false
          type: boolean
          default: false
        - name: size
          in: query
          description: The maximum number of entries or sub-entries to be returned. The default value is 10
          required: false
          type: integer
          default: 10
          minimum: 1
          format: int32
        - name: from
          in: query
          description: From index to start the search from. Defaults to 0.
          required: false
          type: integer
          default: 0
          minimum: 1
          format: int32
        - name: field
          in: query
          description: Name of the field to be used for retrieving the most relevant terms
          required: false
          type: string
          default: _all
        - name: max-age-cache
          in: query
          description: max-age-cache
          required: false
          type: integer
          format: int32
      responses:
        '200':
          description: Successful operation
  /explore/{collection}/_tile/{z}/{x}/{y}.png:
    get:
      tags:
        - explore
      summary: Tiled GeoSearch
      description: Search and return the elements found in the collection(s) and localized in the given tile(x,y,z) as features, given the filters
      operationId: tiledgeosearch_1
      consumes:
        - application/json;charset=utf-8
      produces:
        - image/png
      parameters:
        - name: collection
          in: path
          description: collection
          required: true
          type: string
        - name: x
          in: path
          description: x
          required: true
          type: integer
          format: int32
        - name: 'y'
          in: path
          description: 'y'
          required: true
          type: integer
          format: int32
        - name: z
          in: path
          description: z
          required: true
          type: integer
          format: int32
        - name: f
          in: query
          description: |-
            - A triplet for filtering the result. Multiple filter can be provided in distinct parameters (AND operator is applied) or in the same parameter separated by semi-colons (OR operator is applied). The order does not matter.

            - A triplet is composed of a field name, a comparison operator and a value.

              The possible values of the comparison operator are :

                   Operator        --                   Description                    -- value type

                   :eq:            -- {fieldName} equals {comma separated values}. **OR** operation is applied for the specified values -- numeric or strings

                   :ne:            -- {fieldName} must not equal {comma separated values }. **AND** operation is applied for the specified values -- numeric or strings

                   :like:          -- {fieldName}  is like {value}                     -- numeric or strings

                   :gte:           -- {fieldName} is greater than or equal to  {value} -- numeric

                   :gt:            -- {fieldName} is greater than {value}              -- numeric

                   :lte:           -- {fieldName} is less than or equal to {value}     -- numeric

                   :lt:            -- {fieldName}  is less than {value}                -- numeric

                   :range:         -- {fieldName} is between `{comma separated [min<max] values}`. **OR** operation is applied for the specified ranges -- numeric or strings. If the field's type is date, then min & max should be timestamps in millisecond or a Date expression

                   :within:        -- {GeofieldName}` is within the `{given WKT string or the given BBOX }` -- a WKT string or the BBOX string : `"west, south, east, north"`

                   :notwithin:     -- {GeofieldName} is not within the `{given WKT string or the given BBOX }` -- a WKT string or the BBOX string : `"west, south, east, north"`

                   :intersects:    -- {GeofieldName} intersects the `{given WKT string or the given BBOX }` | a WKT string or the BBOX string : `"west, south, east, north"`

                   :notintersects: -- {GeofieldName} does not intersect the `{given WKT string or the given }` -- a WKT string or the BBOX string : `"west, south, east, north"`
          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: q
          in: query
          description: 'A full text search. Optionally, it''s possible to search on a field using this syntax: {fieldname}:{text}'
          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: dateformat
          in: query
          description: The format of dates. This parameter should be set only if a date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte` and `range` operations
          required: false
          type: string
        - name: righthand
          in: query
          description: |-
            If righthand = true, the passed WKT should be counter clock-wise; otherwise, geo-analytics service will attempt to parse it as the "Complementary" Polygon on the other facet of the planet.
             Inversely, If righthand = false, the passed WKT should be clock-wise; otherwise, geo-analytics service will attempt to parse it as the "Complementary" Polygon on the other facet of the planet.
          required: false
          type: boolean
        - name: size
          in: query
          description: The maximum number of entries or sub-entries to be returned. The default value is 10
          required: false
          type: integer
          default: 10
          minimum: 1
        - name: from
          in: query
          description: From index to start the search from. Defaults to 0.
          required: false
          type: integer
          default: 0
          minimum: 0
        - name: sort
          in: query
          description: |
            Sorts the resulted hits on the given fields and/or by distance to a given point:

            > __**Syntax**__: `{field1},{field2},-{field3},geodistance:{lat} {lon},{field4}  ...`.

            > **Note 1**: `{field}` can be preceded by **'-'**  for **descending** sort. By default, sort is ascending.

            > **Note 2**: The order of fields matters.

            > **Note 3** ***geodistance sort***: Sorts the hits centroids by distance to the given **{lat} {lon}** (ascending distance sort). It can be specified at most 1 time.

            > __**Example 1**__: sort=`age,-timestamp`. Resulted hits are sorted by age. For same age hits, they are decreasingly sorted in time.

            > __**Example 2**__: sort=`age,geodistance:89 179`. Resulted hits are sorted by age. For same age hits, they are sorted by closest distance to the point(89,179)

          required: false
          type: array
          items:
            type: string
          collectionFormat: multi
        - name: after
          in: query
          description: |
            List of values of fields present in sort param that are used to search after.

            > **What it does**: Retrieve the data placed after the pointed element, given the provided order (sort).

            > __**Restriction 1**__: **after** param works only combined with **sort** param.

            > __**Syntax**__: `after={value1},{value2},...,{valueN} & sort={field1},{field2},...,{fieldN}`.

            > **Note 1**: *{value1}` and `{value2}` are the values of `{field1}` and `{field2}` in the last hit returned in the previous search

            > **Note 2**: The order of fields and values matters. *{value1},{value2}* must be in the same order of *{field1},{field2}* in **sort** param

            > **Note 3**:  The last field `{fieldN}` must be the id field specified in the collection **collection.params.idPath** (returned as **md.id**) and `{valueN}` its corresponding value.

            > __**Example**__: *sort=`-date,id` & **after**=`01/02/2019,abcd1234`*. Gets the following hits of the previous search that stopped at date *01/02/2019* and id *abcd1234*.

            > __**Restriction 2**__: **from** param must be set to 0 or kept unset

          required: false
          type: string
        - name: before
          in: query
          description: Same idea that after param, but to retrieve the data placed before the pointed element, given the provided order (sort).
          required: false
          type: string
        - name: sampling
          in: query
          description: 'Size of the sampling for testing transparency: 1: test every pixel, 10: test 1 pixel every 10 pixels, etc.'
          required: false
          type: integer
          default: 10
          format: int32
        - name: coverage
          in: query
          description: Percentage (]0-100]) of acceptable transparent pixels. Higher the percentage, more tiles could be used for filling the tile
          required: false
          type: integer
          default: 70
          format: int32
        - name: max-age-cache
          in: query
          description: max-age-cache
          required: false
          type: integer
          format: int32
      responses:
        '200':
          description: Successful operation
        '400':
          description: Bad request.
          schema:
            $ref: '#/definitions/Error'
        '500':
          description: Server Error.
          schema:
            $ref: '#/definitions/Error'
definitions:
  Bbox:
    type: object
    required:
      - east
      - north
      - south
      - west
    properties:
      north:
        type: number
        format: double
      south:
        type: number
        format: double
      east:
        type: number
        format: double
      west:
        type: number
        format: double
  CollectionDisplayNames:
    type: object
    properties:
      collection:
        type: string
      fields:
        type: object
        additionalProperties:
          type: string
      shape_columns:
        type: object
        additionalProperties:
          type: string
  CollectionReference:
    type: object
    required:
      - collection_name
      - params
    properties:
      collection_name:
        type: string
      params:
        $ref: '#/definitions/CollectionReferenceParameters'
  CollectionReferenceParameters:
    type: object
    required:
      - centroid_path
      - geometry_path
      - id_path
      - index_name
      - timestamp_path
    properties:
      index_name:
        type: string
      id_path:
        type: string
      geometry_path:
        type: string
      centroid_path:
        type: string
      h3_path:
        type: string
      timestamp_path:
        type: string
      exclude_fields:
        type: string
      update_max_hits:
        type: integer
        format: int32
      taggable_fields:
        type: string
      exclude_wfs_fields:
        type: string
      custom_params:
        type: object
        additionalProperties:
          type: string
      display_names:
        $ref: '#/definitions/CollectionDisplayNames'
      atom_feed:
        $ref: '#/definitions/Feed'
      open_search:
        $ref: '#/definitions/OpenSearch'
      inspire:
        $ref: '#/definitions/Inspire'
      dublin_core_element_name:
        $ref: '#/definitions/DublinCoreElementName'
      raster_tile_url:
        $ref: '#/definitions/RasterTileURL'
      raster_tile_width:
        type: integer
        format: int32
      raster_tile_height:
        type: integer
        format: int32
      filter:
        $ref: '#/definitions/Filter'
  DublinCoreElementName:
    type: object
    properties:
      title:
        type: string
      creator:
        type: string
      subject:
        type: string
      description:
        type: string
      publisher:
        type: string
      contributor:
        type: string
      type:
        type: string
      format:
        type: string
      identifier:
        type: string
      source:
        type: string
      language:
        type: string
      bbox:
        $ref: '#/definitions/Bbox'
      date:
        type: string
      coverage:
        type: object
        additionalProperties:
          type: object
      coverage_centroid:
        type: string
  Expression:
    type: object
    properties:
      field:
        type: string
      op:
        type: string
        enum:
          - eq
          - gte
          - gt
          - lte
          - lt
          - like
          - ne
          - range
          - within
          - notwithin
          - intersects
          - notintersects
      value:
        type: string
  Feed:
    type: object
    properties:
      author:
        $ref: '#/definitions/Person'
      contributor:
        $ref: '#/definitions/Person'
      icon:
        type: string
      logo:
        type: string
      rights:
        type: string
      subtitle:
        type: string
      generator:
        $ref: '#/definitions/Generator'
  Filter:
    type: object
    properties:
      f:
        type: array
        items:
          type: array
          items:
            $ref: '#/definitions/Expression'
      q:
        type: array
        items:
          type: array
          items:
            type: string
      dateformat:
        type: string
      righthand:
        type: boolean
  Generator:
    type: object
    properties:
      name:
        type: string
      version:
        type: string
      uri:
        type: string
  Inspire:
    type: object
    properties:
      keywords:
        type: array
        items:
          $ref: '#/definitions/Keyword'
      topic_categories:
        type: array
        items:
          type: string
      lineage:
        type: string
      languages:
        type: array
        items:
          type: string
      spatial_resolution:
        $ref: '#/definitions/InspireSpatialResolution'
      inspire_uri:
        $ref: '#/definitions/InspireURI'
      inspire_limitation_access:
        $ref: '#/definitions/InspireLimitationAccess'
      inspire_use_conditions:
        type: string
  InspireLimitationAccess:
    type: object
    properties:
      access_constraints:
        type: string
      other_constraints:
        type: string
      classification:
        type: string
  InspireSpatialResolution:
    type: object
    properties:
      value:
        $ref: '#/definitions/Number'
      unit_of_measure:
        type: string
  InspireURI:
    type: object
    properties:
      code:
        type: string
      namespace:
        type: string
  Keyword:
    type: object
    properties:
      value:
        type: string
      vocabulary:
        type: string
      date_of_publication:
        type: string
  Number:
    type: object
  OpenSearch:
    type: object
    properties:
      short_name:
        type: string
      description:
        type: string
      contact:
        type: string
      tags:
        type: string
      long_name:
        type: string
      image_height:
        type: string
      image_width:
        type: string
      image_type:
        type: string
      image_url:
        type: string
      developer:
        type: string
      attribution:
        type: string
      syndication_right:
        type: string
      adult_content:
        type: string
      language:
        type: string
      input_encoding:
        type: string
      output_encoding:
        type: string
  Person:
    type: object
    properties:
      name:
        type: string
      email:
        type: string
      uri:
        type: string
  RasterTileURL:
    type: object
    required:
      - id_path
      - url
    properties:
      url:
        type: string
      id_path:
        type: string
      min_z:
        type: integer
        format: int32
      max_z:
        type: integer
        format: int32
      check_geometry:
        type: boolean
  Error:
    type: object
    properties:
      status:
        type: integer
        format: int32
      message:
        type: string
      error:
        type: string
  Success:
    type: object
    properties:
      status:
        type: integer
        format: int32
      message:
        type: string
  AggregationMetric:
    type: object
    properties:
      type:
        type: string
      field:
        type: string
      value:
        type: object
  AggregationResponse:
    type: object
    properties:
      query_time:
        type: integer
        format: int64
      total_time:
        type: integer
        format: int64
      totalnb:
        type: integer
        format: int64
      name:
        type: string
      count:
        type: integer
        format: int64
      sumotherdoccounts:
        type: integer
        format: int64
      key:
        type: object
      key_as_string:
        type: object
      elements:
        type: array
        items:
          $ref: '#/definitions/AggregationResponse'
      metrics:
        type: array
        items:
          $ref: '#/definitions/AggregationMetric'
      hits:
        type: array
        items:
          type: object
      geometries:
        type: array
        items:
          $ref: '#/definitions/ReturnedGeometry'
      flattened_elements:
        type: object
        additionalProperties:
          type: object
  Crs:
    type: object
    properties:
      type:
        type: string
        enum:
          - name
          - link
      properties:
        type: object
        additionalProperties:
          type: object
  Feature:
    type: object
    properties:
      crs:
        $ref: '#/definitions/Crs'
      bbox:
        type: array
        items:
          type: number
          format: double
      properties:
        type: object
        additionalProperties:
          type: object
      geometry:
        $ref: '#/definitions/GeoJsonObject'
      id:
        type: string
  FeatureCollection:
    type: object
    properties:
      crs:
        $ref: '#/definitions/Crs'
      bbox:
        type: array
        items:
          type: number
          format: double
      features:
        type: array
        items:
          $ref: '#/definitions/Feature'
  GeoJsonObject:
    type: object
    discriminator: type
    properties:
      crs:
        $ref: '#/definitions/Crs'
      bbox:
        type: array
        items:
          type: number
          format: double
  GeometryCollection:
    allOf:
      - $ref: '#/definitions/GeoJsonObject'
      - type: object
        properties:
          geometries:
            type: array
            items:
              $ref: '#/definitions/GeoJsonObject'
  LineString:
    allOf:
      - $ref: '#/definitions/GeoJsonObject'
      - type: object
        properties:
          coordinates:
            type: array
            items:
              $ref: '#/definitions/LngLatAlt'
  LngLatAlt:
    type: object
    properties:
      longitude:
        type: number
        format: double
      latitude:
        type: number
        format: double
      altitude:
        type: number
        format: double
      additionalElements:
        type: array
        items:
          type: number
          format: double
  MultiLineString:
    allOf:
      - $ref: '#/definitions/GeoJsonObject'
      - type: object
        properties:
          coordinates:
            type: array
            items:
              type: array
              items:
                $ref: '#/definitions/LngLatAlt'
  MultiPoint:
    allOf:
      - $ref: '#/definitions/GeoJsonObject'
      - type: object
        properties:
          coordinates:
            type: array
            items:
              $ref: '#/definitions/LngLatAlt'
  MultiPolygon:
    allOf:
      - $ref: '#/definitions/GeoJsonObject'
      - type: object
        properties:
          coordinates:
            type: array
            items:
              type: array
              items:
                type: array
                items:
                  $ref: '#/definitions/LngLatAlt'
  Point:
    allOf:
      - $ref: '#/definitions/GeoJsonObject'
      - type: object
        properties:
          coordinates:
            $ref: '#/definitions/LngLatAlt'
  Polygon:
    allOf:
      - $ref: '#/definitions/GeoJsonObject'
      - type: object
        properties:
          coordinates:
            type: array
            items:
              type: array
              items:
                $ref: '#/definitions/LngLatAlt'
  ReturnedGeometry:
    type: object
    properties:
      reference:
        type: string
      geometry:
        $ref: '#/definitions/GeoJsonObject'
      sort:
        type: string
      is_raw:
        type: boolean
  Aggregation:
    type: object
    properties:
      type:
        type: string
        enum:
          - datehistogram
          - geohash
          - geotile
          - histogram
          - term
          - h3
      field:
        type: string
      interval:
        $ref: '#/definitions/Interval'
      format:
        type: string
      metrics:
        type: array
        items:
          $ref: '#/definitions/Metric'
      order:
        type: string
        enum:
          - asc
          - desc
      'on':
        type: string
        enum:
          - field
          - count
          - result
      size:
        type: string
      include:
        type: string
      raw_geometries:
        type: array
        items:
          $ref: '#/definitions/RawGeometry'
      aggregated_geometries:
        type: array
        items:
          type: string
          enum:
            - BBOX
            - CENTROID
            - CELL
            - CELLCENTER
            - GEOHASH
            - GEOHASH_CENTER
      fetch_hits:
        $ref: '#/definitions/HitsFetcher'
  AggregationsRequest:
    type: object
    properties:
      filter:
        $ref: '#/definitions/Filter'
      form:
        $ref: '#/definitions/Form'
      aggregations:
        type: array
        items:
          $ref: '#/definitions/Aggregation'
  Form:
    type: object
    properties:
      pretty:
        type: boolean
      flat:
        type: boolean
  HitsFetcher:
    type: object
    properties:
      size:
        type: integer
        format: int32
      include:
        type: array
        items:
          type: string
  Interval:
    type: object
    properties:
      value:
        $ref: '#/definitions/Number'
      unit:
        type: string
        enum:
          - year
          - quarter
          - month
          - week
          - day
          - hour
          - minute
          - second
  Metric:
    type: object
    properties:
      collect_field:
        type: string
      collect_fct:
        type: string
        enum:
          - AVG
          - CARDINALITY
          - MAX
          - MIN
          - SUM
          - GEOCENTROID
          - GEOBBOX
  RawGeometry:
    type: object
    properties:
      geometry:
        type: string
      sort:
        type: string
  ComputationResponse:
    type: object
    properties:
      query_time:
        type: integer
        format: int64
      total_time:
        type: integer
        format: int64
      totalnb:
        type: integer
        format: int64
      field:
        type: string
      metric:
        type: string
        enum:
          - AVG
          - MAX
          - MIN
          - SUM
          - CARDINALITY
          - SPANNING
          - GEOBBOX
          - GEOCENTROID
      value:
        type: number
        format: double
      geometry:
        $ref: '#/definitions/GeoJsonObject'
  ComputationRequest:
    type: object
    properties:
      filter:
        $ref: '#/definitions/Filter'
      form:
        $ref: '#/definitions/Form'
      field:
        type: string
      metric:
        type: string
        enum:
          - AVG
          - MAX
          - MIN
          - SUM
          - CARDINALITY
          - SPANNING
          - GEOBBOX
          - GEOCENTROID
  Geo:
    type: object
    properties:
      path:
        type: string
      geometry:
        $ref: '#/definitions/GeoJsonObject'
  Hit:
    type: object
    properties:
      md:
        $ref: '#/definitions/MD'
      data:
        type: object
  Hits:
    type: object
    properties:
      collection:
        type: string
      hits:
        type: array
        items:
          $ref: '#/definitions/Hit'
      nbhits:
        type: integer
        format: int64
      totalnb:
        type: integer
        format: int64
      links:
        type: object
        additionalProperties:
          $ref: '#/definitions/Link'
  Link:
    type: object
    required:
      - href
      - method
    properties:
      href:
        type: string
      method:
        type: string
      body:
        type: object
  MD:
    type: object
    properties:
      id:
        type: string
      timestamp:
        type: integer
        format: int64
      geometry:
        $ref: '#/definitions/GeoJsonObject'
      centroid:
        $ref: '#/definitions/GeoJsonObject'
      returned_geometries:
        type: array
        items:
          $ref: '#/definitions/Geo'
  Count:
    type: object
    properties:
      filter:
        $ref: '#/definitions/Filter'
      form:
        $ref: '#/definitions/Form'
  CollectionReferenceDescription:
    type: object
    required:
      - collection_name
      - params
    properties:
      properties:
        type: object
        additionalProperties:
          $ref: '#/definitions/CollectionReferenceDescriptionProperty'
      collection_name:
        type: string
      params:
        $ref: '#/definitions/CollectionReferenceParameters'
  CollectionReferenceDescriptionProperty:
    type: object
    properties:
      type:
        type: string
        enum:
          - TEXT
          - KEYWORD
          - LONG
          - INTEGER
          - SHORT
          - BYTE
          - DOUBLE
          - FLOAT
          - DATE
          - BOOLEAN
          - BINARY
          - INT_RANGE
          - FLOAT_RANGE
          - LONG_RANGE
          - DOUBLE_RANGE
          - DATE_RANGE
          - OBJECT
          - NESTED
          - GEO_POINT
          - GEO_SHAPE
          - IP
          - COMPLETION
          - TOKEN_COUNT
          - MAPPER_MURMUR3
          - UNKNOWN
          - VARCHAR
          - CHAR
          - CHARACTER
          - BIT
          - TINYINT
          - SMALLINT
          - INT
          - BIGINT
          - DECIMAL
          - NUMERIC
          - REAL
          - DOUBLEPRECISION
          - TIMESTAMP
          - TIME
          - INTERVAL
          - GEOMETRY
          - GEOGRAPHY
          - POINT
          - LINESTRING
          - POLYGON
          - MULTIPOINT
          - MULTILINESTRING
          - MULTIPOLYGON
          - GEOMETRYCOLLECTION
      format:
        type: string
      properties:
        type: object
        additionalProperties:
          $ref: '#/definitions/CollectionReferenceDescriptionProperty'
      taggable:
        type: boolean
      indexed:
        type: boolean
  Page:
    type: object
    properties:
      size:
        type: integer
        format: int32
      from:
        type: integer
        format: int32
      sort:
        type: string
      after:
        type: string
      before:
        type: string
  Projection:
    type: object
    properties:
      includes:
        type: string
      excludes:
        type: string
  Search:
    type: object
    properties:
      filter:
        $ref: '#/definitions/Filter'
      form:
        $ref: '#/definitions/Form'
      page:
        $ref: '#/definitions/Page'
      projection:
        $ref: '#/definitions/Projection'
      returned_geometries:
        type: string
